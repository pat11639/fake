<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Pat Shaughnessy</title><id>http://patshaughnessy.net</id><updated>2020-01-20T17:08:40Z</updated><author><name>Pat Shaughnessy</name></author><entry><title>Downloading 100,000 Files Using Async Rust</title><link href="http://patshaughnessy.net/2020/1/20/downloading-100000-files-using-async-rust" rel="alternate"></link><id href="http://patshaughnessy.net/2020/1/20/downloading-100000-files-using-async-rust" rel="alternate"></id><published>2020-01-20T00:00:00Z</published><updated>2020-01-20T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/traffic-light.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust's new async/await feature makes it &lt;br/&gt;
easy to stop and start asynchronous tasks&lt;/i&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Red_and_green_traffic_signals,_Stamford_Road,_Singapore_-_201</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/traffic-light.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust's new async/await feature makes it &lt;br/&gt;
easy to stop and start asynchronous tasks&lt;/i&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Red_and_green_traffic_signals,_Stamford_Road,_Singapore_-_20111210.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;Imagine if you had a text file containing thousands of URLs:&lt;/p&gt;
&lt;pre&gt;
$ cat urls.txt
https://example.com/1.html
https://example.com/2.html
https://example.com/3.html

etc...

https://example.com/99999.html
https://example.com/100000.html
&lt;/pre&gt;
&lt;p&gt;…and you needed to download all of those HTML pages efficiently. How would you
do it? Maybe a shell script using &lt;span class=&quot;code&quot;&gt;xargs&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;curl&lt;/span&gt;? Maybe a simple Golang program? Go’s powerful
concurrency features would work well for this.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;p&gt;Instead, I decided to try to use Rust. I’ve read a lot about safe concurrency
in Rust, but I’ve never tried it. I also wanted to learn what Rust’s new
“async/await” feature was all about. This seemed like the perfect task for
asynchronous Rust code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL/DR&lt;/em&gt;: &lt;a href=&quot;https://gist.github.com/patshaughnessy/27b1611e2c912346b929df97998d488d&quot;&gt;Here’s the
code&lt;/a&gt;.
The rest of this post will explain how it works.&lt;/p&gt;
&lt;h2&gt;Getting Started With Reqwest&lt;/h2&gt;
&lt;p&gt;There are many different Rust HTTP clients to choose from, and &lt;a href=&quot;https://medium.com/@shnatsel/smoke-testing-rust-http-clients-b8f2ee5db4e6&quot;&gt;apparently some
controversy&lt;/a&gt;
about which works best. Because I’m a Rust newbie, I decided simply to pick the most
popular: &lt;a href=&quot;https://github.com/seanmonstar/reqwest&quot;&gt;reqwest&lt;/a&gt;. Request is a high
level, easy to use HTTP client, written by &lt;a href=&quot;https://seanmonstar.com/&quot;&gt;Sean
McArthur&lt;/a&gt;. He just updated it to work with Tokio,
Rust’s new async/await engine, so this is the perfect time to try using it.
Here’s the example from the readme:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;use &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;std::collections::HashMap;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#[tokio::main]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://httpbin.org/ip&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .await&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .json::&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .await&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:#?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, resp);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(())
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This version downloads some JSON and parses it. Notice the new &lt;span
class=&quot;code&quot;&gt;async&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; keywords. The
main function is &lt;span class=&quot;code&quot;&gt;async&lt;/span&gt; - this means that the function
becomes part of a large state machine run by Tokio. When you mark a function
asynchronous, you can then call &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; inside it,
which will pause that function temporarily, allowing other asynchronous
functions to run on the same thread.&lt;/p&gt;
&lt;p&gt;I decided to modify this to print out the number of bytes downloaded instead; you could
easily change it to save the data to a file or do whatever you want.&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://httpbin.org/ip&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(())
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is a two step process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;First I call &lt;span class=&quot;code&quot;&gt;get(path)&lt;/span&gt; to send the HTTP GET request. Then I use &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; to wait for
the request to finish and return a result.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Second, if the request was successful, I call &lt;span
class=&quot;code&quot;&gt;resp.text()&lt;/span&gt; to get the contents of the response body. And
I wait again while that is loaded.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I handle the errors explicitly and always return a unit result &lt;span
class=&quot;code&quot;&gt;Ok(())&lt;/span&gt; because that makes the code below simpler
when I start downloading more than one page concurrently.&lt;/p&gt;
&lt;p&gt;Visually, I can draw the &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;text&lt;/span&gt; calls like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/get-and-text.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;First I call &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and wait, then I call &lt;span
class=&quot;code&quot;&gt;text&lt;/span&gt; and wait.&lt;/p&gt;
&lt;p&gt;But what is asynchronous about this? This reads like normal, single threaded
code. I do one thing, then I do another.&lt;/p&gt;
&lt;h2&gt;Sending 3 Concurrent Requests&lt;/h2&gt;
&lt;p&gt;The magic happens when I have more than one request I want to make in parallel. Let’s use three hard coded path strings:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;vec![
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/1.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/2.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/3.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;To download the 3 HTML files in parallel, I spawn three Tokio “tasks” and wait
for them all to complete. (This requires adding the futures crate to
Cargo.toml, which implements &lt;span class=&quot;code&quot;&gt;join_all&lt;/span&gt;.)&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Iterate over the paths.
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; tasks: Vec&amp;lt;JoinHandle&amp;lt;Result&amp;lt;(), ()&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;vec![];
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Copy each path into a new string
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// that can be consumed/captured by the task closure
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path.clone();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Create a Tokio task for each path
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    tasks.push(tokio::spawn(async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;move &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(())
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }));
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Wait for them all to finish
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Started &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; tasks. Waiting...&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, tasks.len());
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;join_all(tasks).await;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Each Tokio task is a closure passed to the &lt;span
class=&quot;code&quot;&gt;tokio::spawn&lt;/span&gt; function, marked &lt;span class=&quot;code&quot;&gt;async
move&lt;/span&gt;. I create a copy of each path, using &lt;span
class=&quot;code&quot;&gt;path.clone()&lt;/span&gt;, so the closure has its own copy of the path
string with its own lifetime.&lt;/p&gt;
&lt;p&gt;The complex type annotation on the &lt;span class=&quot;code&quot;&gt;tasks&lt;/span&gt; array
indicates what each call to &lt;span class=&quot;code&quot;&gt;spawn&lt;/span&gt; returns: a &lt;span
class=&quot;code&quot;&gt;JoinHandle&lt;/span&gt; enclosing a &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt;. To
keep things simple, I handle all errors in the closure and just return &lt;span
class=&quot;code&quot;&gt;Ok(())&lt;/span&gt;.  This means each &lt;span
class=&quot;code&quot;&gt;JoinHandle&lt;/span&gt; contains a trivial result: &lt;span
class=&quot;code&quot;&gt;Result&amp;lt;(), ()&amp;gt;&lt;/span&gt;. I could have written the closure to return
some value and/or some error value instead.&lt;/p&gt;
&lt;p&gt;After the loop is finished and all three tasks have been spawned, I call &lt;span
class=&quot;code&quot;&gt;join_all(tasks).await&lt;/span&gt; to wait for them all to finish.&lt;/p&gt;
&lt;h2&gt;Asynchronous vs Multithreaded&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/traffic-light2.jpg&quot;&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Traffic_lights,_Zl%C3%ADn.JPG&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;At first glance, it looks like this code is spawning three different threads. I
even call a spawn function. A multithreaded download might look like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/multithreaded.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;We have 3 paths, so we have 3 threads. Each thread calls &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and waits, and
then calls &lt;span class=&quot;code&quot;&gt;text&lt;/span&gt; and waits.&lt;/p&gt;
&lt;p&gt;However, Rust’s Tokio engine doesn’t work that way. Instead of launching an
entirely new thread for each task, it runs all three tasks on the same thread.
I imagine three tasks running on one thread like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/one-thread.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Each time I call &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt;, Rust stops one task and
starts another using the same thread. In fact, depending on how long it takes
for each task to complete, they might be run in a different order:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/different-order.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;There’s no way to predict ahead of time what order the tasks will run it.
That’s why I needed to copy each path string above; each task needs it own copy
of the string with its own independent lifetime because it might be run at any
time.&lt;/p&gt;
&lt;p&gt;The only guarantee I have is that the &lt;span class=&quot;code&quot;&gt;join_all&lt;/span&gt; call
at the bottom will block until all of the tasks have finished; that is, until
all of the futures I pushed onto the tasks array have completed.&lt;/p&gt;
&lt;h2&gt;Sending 100,000 Concurrent Requests&lt;/h2&gt;
&lt;p&gt;I can scale this up to 100,000 requests by reading the URLs in from a file instead:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;read_lines&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(path: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) -&amp;gt; Result&amp;lt;Vec&amp;lt;String&amp;gt;, Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(path)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; reader &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;BufReader::new(file);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        reader.lines().filter_map(Result::ok).collect()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    )
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#[tokio::main]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;	&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths: Vec&amp;lt;String&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;read_lines(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;urls.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;When I tried this out for the first time I was excited: How long would it take
to download 100,000 HTML pages simultaneously like this? Would it be 100,000x
faster than downloading one file? I typed &lt;span class=&quot;code&quot;&gt;cargo run
--release&lt;/span&gt; to build my code in release mode and get the best possible
performance out of Rust. Asynchronous code, zero cost abstractions, no garbage
collector, this was going to be great!&lt;/p&gt;
&lt;p&gt;Of course, it didn’t work.&lt;/p&gt;
&lt;p&gt;What happened? The problem is the web server can't handle so many concurrent network
connections. Using my thread/task diagram, launching all 100,000 tasks might
look like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/simultaneous.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;I spawn 100,000 tasks all on to the same thread, and Tokio starts executing
them all. Each time my code above calls &lt;span
class=&quot;code&quot;&gt;get(&amp;amp;path).await&lt;/span&gt;, Tokio pauses that task and starts
another, which calls &lt;span class=&quot;code&quot;&gt;get(&amp;amp;path).await&lt;/span&gt; again, opening
yet another HTTP request. My laptop quickly runs out of network resources and
these tasks start to fail.&lt;/p&gt;
&lt;h2&gt;Sending a Buffered, Concurrent Stream of 100,000 Requests&lt;/h2&gt;
&lt;p&gt;Instead, I need to limit the number of concurrent Tokio tasks - the number of
concurrent HTTP requests. I need the diagram to look something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/buffered.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;After the first 8 tasks are started, the first 8 blue boxes on the left, Tokio
waits for at least one of them to complete before starting a 9th task. I
indicate this with the “max concurrency” arrow.&lt;/p&gt;
&lt;p&gt;Once one of the first 8 calls to &lt;span class=&quot;code&quot;&gt;reqwest::get&lt;/span&gt;
completes, Tokio is free to run a 9th task. The first &amp;quot;pop from buffer&amp;quot; arrow.
And once that 9th task or any other task completes, Tokio starts a 10th task,
etc., in this manner processing all 100,000 tasks 8 at a time.&lt;/p&gt;
&lt;p&gt;To achieve this, I can use &lt;span class=&quot;code&quot;&gt;StreamExt&lt;/span&gt; trait’s &lt;a
href=&quot;https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.5/futures/stream/trait.StreamExt.html#method.buffer_unordered&quot;&gt;&lt;span
class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt;&lt;/a&gt; function:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; fetches &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;futures::stream::iter(
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    paths.into_iter().map(|path| {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;move &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                            println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;})
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).buffer_unordered(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).collect::&amp;lt;Vec&amp;lt;()&amp;gt;&amp;gt;();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Waiting...&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;fetches.await;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;First I create an iterator which maps all of the paths to my closures, and passes
them to &lt;span class=&quot;code&quot;&gt;futures::stream::iter&lt;/span&gt;.
This will create a list of futures, each one executing my closure.&lt;/p&gt;
&lt;p&gt;At the bottom I call &lt;span class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; and pass in 8.  The
code in &lt;span class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; will execute up to 8 futures
from the stream concurrently, and then start to buffer the remaining futures.
As each task completes, each HTTP request in my example, &lt;span
class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; will pull another task out of its buffer
and execute it.&lt;/p&gt;
&lt;p&gt;This code will slowly but steadily iterate over the 100,000 URLs, downloading
them in parallel. Experimenting with this, it doesn’t seem to matter very much
exactly what level of concurrency I pick. I found the best performance when I
picked a concurrency of 50. Using 50 concurrent Tokio tasks, it took about 30
minutes to all one hundred thousand HTML files.&lt;/p&gt;
&lt;p&gt;However, none of that matters. I’m not measuring the performance of Rust, Tokio
or Reqwest. These numbers have more to do with the web server and network
connection I’m using. The real performance here was my own developer
performance: With just a few lines of code I was able to write an asynchronous
I/O program that can scale as much as I would like. The &lt;span
class=&quot;code&quot;&gt;async&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; keywords make
this code easy to write and easy to read.&lt;/p&gt;
</content></entry><entry><title>Using Result Combinator Functions in Rust</title><link href="http://patshaughnessy.net/2019/11/19/using-result-combinator-functions-in-rust" rel="alternate"></link><id href="http://patshaughnessy.net/2019/11/19/using-result-combinator-functions-in-rust" rel="alternate"></id><published>2019-11-19T00:00:00Z</published><updated>2019-11-19T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/11/19/train-yard.jpeg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust’s Result type can help you control your program’s&lt;br/&gt;
  flow by checking for errors in a succinct, elegant way&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Using Rust for the first time, error handling was my biggest stumbling block.
Was this v</summary><content type="html">&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/11/19/train-yard.jpeg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust’s Result type can help you control your program’s&lt;br/&gt;
  flow by checking for errors in a succinct, elegant way&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Using Rust for the first time, error handling was my biggest stumbling block.
Was this value a &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; or just a T?  And the
right T? The right E? I couldn’t just write the code I wanted to write. It
felt confusing and overly elaborate.&lt;/p&gt;
&lt;p&gt;But after a while, I started to get a feel for the basics of using &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt;. I discovered that the combinator methods Result
provides, like &lt;span class=&quot;code&quot;&gt;map&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;or_else&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;ok&lt;/span&gt;, made error handling fun. Well, maybe
that's a bit of an overstatement. They made using &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt; a bit easier, at least.&lt;/p&gt;
&lt;p&gt;So far my favorite &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; combinator method is
&lt;a
href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then&quot;&gt;&lt;span
class=&quot;code&quot;&gt;and_then&lt;/span&gt;&lt;/a&gt;. Using &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; &lt;em&gt;is&lt;/em&gt;
actually fun! For example, I wrote &lt;a href=&quot;https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/src/lib.rs#L43&quot;&gt;this Rust
code&lt;/a&gt;
to generate the static HTML pages for this blog site:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; count &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; all_posts.len();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;all_posts.sort_by_key(|p| Reverse(p.date));
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; params &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; CompileParams {all_posts: all_posts, output_path: output_path, draft: draft};
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(params).and_then(compile_posts)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_home_page)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_rss_feed)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .map(|_output| count)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Ignoring the details about sorting and counting, my code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First creates a struct holding input parameters, and wraps it using &lt;span class=&quot;code&quot;&gt;Ok(params)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;And then&lt;/em&gt; tries to compile all the posts in my blog, passing in the input parameters&lt;/li&gt;
&lt;li&gt;&lt;em&gt;And then&lt;/em&gt; if this was successful, it tries to compile the home page
(index.html)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;And then&lt;/em&gt; if this was successful, it tries to compile the RSS feed (index.xml)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If there was an error at any time in this process, it short circuits and stops.
Here’s a flowchart that illustrates this control flow:&lt;/p&gt;
&lt;div style=&quot;margin-left: auto; margin-right: auto; width:235px&quot;&gt;
&lt;br/&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2019/11/19/flowchart.png&quot;&gt;
&lt;/div&gt;
&lt;p&gt;The happy path is from top to bottom, along the left side. If any of the
compile methods fail, &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; short circuits the
happy path and jumps to the end.&lt;/p&gt;
&lt;h2&gt;Matching Result Types&lt;/h2&gt;
&lt;p&gt;To chain &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; methods together like this, I used
the same input and output types for each of the compile methods:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_posts&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params: CompileParams) -&amp;gt; Result&amp;lt;CompileParams, InvalidPostError&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_home_page&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params: CompileParams) -&amp;gt; Result&amp;lt;CompileParams, InvalidPostError&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_rss_feed&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params: CompileParams) -&amp;gt; Result&amp;lt;CompileParams, InvalidPostError&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Each method expects a &lt;span class=&quot;code&quot;&gt;CompileParams&lt;/span&gt; struct, and
returns one wrapped in &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt;. Rust unwraps the &lt;span
class=&quot;code&quot;&gt;CompileParams&lt;/span&gt; from one call and passes it to the next.&lt;/p&gt;
&lt;p&gt;I use &lt;span class=&quot;code&quot;&gt;InvalidPostError&lt;/span&gt; throughout my code to provide
a consistent way to return errors. This was a bit of a challenge at first,
until I realized it was easy to cast other types of errors into
&lt;span class=&quot;code&quot;&gt;InvalidPostError&lt;/span&gt; like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;impl &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;From&amp;lt;std::io::Error&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;InvalidPostError {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;from&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(e: std::io::Error) -&amp;gt; InvalidPostError {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; message &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;format!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        InvalidPostError::new(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;message)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Now the Rust compiler knows how to map a &lt;span class=&quot;code&quot;&gt;std::io::Error&lt;/span&gt; into an &lt;span class=&quot;code&quot;&gt;InvalidPostError&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Error Handling the Old Fashioned Way&lt;/h2&gt;
&lt;p&gt;Here’s the code I didn’t have to write: (This is Ruby; substitute your favorite
PL that doesn't support &lt;a href=&quot;https://medium.com/@huund/monadic-error-handling-1e2ce66e3810&quot;&gt;monadic error
handling&lt;/a&gt;.)&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; compile_posts(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; compile_home_page(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; compile_rss_feed(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Success!&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Error compiling RSS Feed&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Error compiling home page&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Error compiling a blog post&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;I didn’t have to write a series of if/else blocks. This would have been tedious
to write and tedious to read. And I probably would have forgotten (or have been
too lazy) to check one of the return values.&lt;/p&gt;
&lt;p&gt;And I didn’t have to write this code either:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_posts&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;InvalidPostError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Failed compiling the posts&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_home_page&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;InvalidPostError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Failed compiling the home page&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_rss_feed&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;InvalidPostError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Failed compiling the RSS feed&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;begin
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  compile_posts(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  compile_home_page(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  compile_rss_feed(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Success&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;rescue &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;InvalidPostError =&amp;gt; e
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts e.message
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Once again this is fragile: I might raise the wrong exception type or not raise
one at all. Or I might rescue the wrong type. Worse, there’s no indication at
the call site what might happen.&lt;/p&gt;
&lt;p&gt;To be honest, I probably won’t bother handling errors at all for a simple Ruby
script like this. If an exception happens someday while building my blog site,
then I’ll deal with it then. I’d probably just write this code:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;compile_posts(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;compile_home_page(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;compile_rss_feed(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Success&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Rust Error Handling: Easy To Read, Hard To Write&lt;/h2&gt;
&lt;p&gt;Combining results together using &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; and other
&lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; functions enables me to write error checking
code in a natural, succinct way:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(params).and_then(compile_posts)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_home_page)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_rss_feed)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is just as simple to read as the Ruby version above that doesn’t check for
any errors. While it’s harder to write, having the Rust compiler check my
thought process as I piece together different code paths is a huge help.
Learning to use and get along with the Rust compiler is worth it: You end up
with code that is both readable and correct.&lt;/p&gt;
</content></entry><entry><title>How Rust Makes Error Handling Part of the Language</title><link href="http://patshaughnessy.net/2019/10/3/how-rust-makes-error-handling-part-of-the-language" rel="alternate"></link><id href="http://patshaughnessy.net/2019/10/3/how-rust-makes-error-handling-part-of-the-language" rel="alternate"></id><published>2019-10-03T00:00:00Z</published><updated>2019-10-03T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/fingers-toes.png&quot;&gt;&lt;br/&gt;
&lt;i&gt;In Spanish these are all “dedos,” while in English&lt;br/&gt;we can distinguish between fingers and toes. &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Learning a foreign language can be an incredible experience, not only because
you can talk to new people, v</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/fingers-toes.png&quot;&gt;&lt;br/&gt;
&lt;i&gt;In Spanish these are all “dedos,” while in English&lt;br/&gt;we can distinguish between fingers and toes. &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Learning a foreign language can be an incredible experience, not only because
you can talk to new people, visit new countries, read new books, etc. When you
learn the words someone from a different culture uses, you start to see things
from their perspective. You understand the way they think a bit more.&lt;/p&gt;
&lt;p&gt;The same is true for programming languages. Learning the syntax, keywords and
patterns of a new programming language enables you to think about problems from
a different perspective. You learn to solve problems in a different way.&lt;/p&gt;
&lt;p&gt;I’ve been studying &lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt; recently, a new
programming language for me. As a Ruby developer, I was curious to learn how
Rust developers approach solving problems. What do Rust programs look like?
What new words would I learn?&lt;/p&gt;
&lt;h2&gt;Why Rust Was Difficult For Me&lt;/h2&gt;
&lt;p&gt;I knew it would be a challenge to learn Rust. I had heard horror stories about
how difficult the Rust compiler can be to use, or about how confusing the
ownership memory model and the borrow checker can be. And I was right: Rust is
a very difficult language to learn. But not because of move semantics or memory
management.&lt;/p&gt;
&lt;p&gt;For me, the most challenging syntax in Rust had to do with simple error
handling. Let’s take an example: opening and reading a text file. In Ruby, this
is a one-liner and error handling is completely optional:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;string &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;File&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.read(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;In Ruby, &lt;span class=&quot;code&quot;&gt;File.read&lt;/span&gt; returns a simple string. Will this
ever return an error? Who knows. Maybe Ruby will raise an exception, maybe not.
I don’t have to worry about that at the call site when I’m writing the code. I
can focus on the happy path, but I end up with a program that can’t handle
errors.&lt;/p&gt;
&lt;p&gt;Golang, at least, returns an error value explicitly when I try to read a file:&lt;/p&gt;
&lt;pre&gt;
b, err := ioutil.ReadFile(&quot;foo.txt&quot;)
if err != nil {
    fmt.Print(err)
} else {
    str := string(b)
}
&lt;/pre&gt;
&lt;p&gt;Here the Golang &lt;span class=&quot;code&quot;&gt;ioutil.ReadFile&lt;/span&gt; function returns two
values: the string I want and also an error value. The Go compiler forces me to
think about errors that might occur, at least for a moment. But error handling
is still optional. I can simply choose to ignore the &lt;span
class=&quot;code&quot;&gt;err&lt;/span&gt; value entirely. Most C programs work in a similar
fashion, returning an error code in some manner.  And if I do choose to handle
the error, I end up with verbose, messy code that checks for error codes over
and over again.&lt;/p&gt;
&lt;p&gt;In Rust error handling in mandatory. Let’s try to rewrite the same example
using Rust:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents);
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Right away I run into trouble when I try to compile this:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
error[E0599]: no method named `read_to_string` found for type
`std::result::Result&amp;lt;std::fs::File, std::io::Error&gt;` in the current scope
&lt;/pre&gt;
&lt;p&gt;What? What is the Rust compiler talking about? I can see there’s a &lt;span
class=&quot;code&quot;&gt;read_to_string&lt;/span&gt; method on the &lt;span class=&quot;code&quot;&gt;File&lt;/span&gt;
struct &lt;a href=&quot;https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string&quot;&gt;right in the
documentation&lt;/a&gt;!
(Actually the method is on the &lt;span class=&quot;code&quot;&gt;Read&lt;/span&gt; trait which &lt;span
class=&quot;code&quot;&gt;File&lt;/span&gt; implements.) The problem is the &lt;span
class=&quot;code&quot;&gt;File::open&lt;/span&gt; function doesn’t return a file at all. It
returns a value of type &lt;span class=&quot;code&quot;&gt;io::Result&amp;lt;File&amp;gt;&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;pub fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;open&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;File&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;How do I use this? What does &lt;span class=&quot;code&quot;&gt;io::Result&amp;lt;File&amp;gt;&lt;/span&gt; even
mean? When I try to write Rust code the way I write Ruby or Go code, I get
cryptic errors and it doesn’t work.&lt;/p&gt;
&lt;p&gt;The problem is I’m trying to speak Rust the same way I speak in Ruby. Rust is a
foreign language; I need to learn some vocabulary before I can try to talk to
someone. This is why Rust is difficult to learn. It’s a foreign language that
uses many words completely unfamiliar to most developers.&lt;/p&gt;
&lt;h2&gt;Types Are the Vocabulary of Programming Languages&lt;/h2&gt;
&lt;p&gt;My wife is Spanish, and lucky for me she’s had the patience and the endurance
to teach me and our kids Spanish over the years. As a native English speaker,
it always seemed curious and amusing to me that Spanish has only one word for
fingers and toes, &lt;em&gt;dedos&lt;/em&gt;. Don’t people in Spain or Latin America ever need to
talk about only fingers and not toes? Or vice-versa? And in Spain I invariably
end up saying silly things like &lt;em&gt;dedos altos&lt;/em&gt; (“upper fingers”), or &lt;em&gt;dedos
bajos&lt;/em&gt; (“lower fingers”). I always worry about which digits I’m talking about.
Somehow, though, the Spanish never have any trouble with this; where the
&lt;em&gt;dedos&lt;/em&gt; are located always seems obvious to them from the context.&lt;/p&gt;
&lt;p&gt;But I wonder: Do Spanish speakers have trouble learning English when it comes
to fingers vs. toes? Do they ever say finger when they mean toe? The problem is
not just learning a new word. You have to learn the meaning behind the word.
English has a concept, a distinction, that Spanish doesn’t.&lt;/p&gt;
&lt;p&gt;Back to computer programming, the “words” we use in programming languages
aren’t only syntax tokens like if, else, let, etc. They are the values that we
pass around in our programs. And those values have types, even for loosely,
dynamically typed languages like Ruby.&lt;/p&gt;
&lt;p&gt;Aside from whatever formal definition Computer Science has for types, I simply
think of a value’s type as it’s meaning or purpose. To understand what role a
value plays in your program, you need to understand the concept behind its
type. Just like the words finger and toe represent certain anatomical concepts
in English, types like &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; or &lt;span
class=&quot;code&quot;&gt;Option&amp;lt;T&amp;gt;&lt;/span&gt; represent programming concepts in Rust - concepts
that foreigners need to learn for the first time.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
Language shapes the way we think, and determines what we can think about.&lt;br/&gt;
-- Benjamin Lee Whorf
&lt;/blockquote&gt;
&lt;p&gt;In fact, some linguists take this to the extreme: That a language’s words
determine what people in that community are able to think and talk about, what
concepts they can understand. (However, most modern linguists, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linguistic_relativity&quot;&gt;according to
Wikipedia&lt;/a&gt;, don’t believe
this is actually true.)&lt;/p&gt;
&lt;p&gt;Because Rust includes the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; type, Rust
programmers are empowered to talk about error handling in a very natural way.
It’s part of their daily vocabulary. Of course, native Spanish speakers, I’m
guessing, have no trouble understanding the distinction between fingers and
toes. But I certainly have trouble understanding the concept behind &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt; in Rust.&lt;/p&gt;
&lt;h2&gt;If Rust is Spanish, then Haskell is Latin&lt;/h2&gt;
&lt;p&gt;So what does &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; mean? What is a value of
type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;Just as human language borrow words from other languages — many Spanish words
are taken from Latin or Arabic while English borrowed many words from French and
German — programming languages borrow words and concepts from other, older
programming languages.&lt;/p&gt;
&lt;p&gt;Rust borrowed the concept behind the &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;
type from Haskell, a strongly typed functional programming language. Haskell
includes a type called &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
data Either a b = Left a | Right b
&lt;/pre&gt;
&lt;p&gt;This syntax seems bizarre at first glance but in fact it’s simple. Haskell
makes it easy to create new types by combining other types together. This line
of code means the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; type is a combination of two
other types: &lt;span class=&quot;code&quot;&gt;a&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;b&lt;/span&gt;.
Drawing that type equation, this is how I visualize Haskell &lt;span
class=&quot;code&quot;&gt;Either&lt;/span&gt; values:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/left-or-right.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;A single &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value can only encapsulate &lt;em&gt;either&lt;/em&gt;
a value of type &lt;span class=&quot;code&quot;&gt;a&lt;/span&gt; or a value of type &lt;span
class=&quot;code&quot;&gt;b&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value is &lt;span
class=&quot;code&quot;&gt;Left&lt;/span&gt;, then it contains an inner value of type &lt;span
class=&quot;code&quot;&gt;a&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Left a&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value is &lt;span
class=&quot;code&quot;&gt;Right&lt;/span&gt;, then it contains an inner value of type &lt;span
class=&quot;code&quot;&gt;b&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Right b&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; type is also “monad,” because Haskell
provides certain functions that create and operate on &lt;span
class=&quot;code&quot;&gt;Either&lt;/span&gt; values. I won’t cover this concept here today, but
when I have time I'll discuss monads and how they can be applied to error
handling in a future post.&lt;/p&gt;
&lt;p&gt;In Haskell, the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; type is completely general,
and you can use it to represent any programming concept you would like.  Rust
uses the concept behind &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; for a specific
purpose: to implement error handling. If Haskell is Latin, then Rust is
Spanish, a younger language that borrows some of the older languages’s
vocabulary and grammar.&lt;/p&gt;
&lt;h2&gt;Result&amp;lt;T, E&amp;gt; in Rust&lt;/h2&gt;
&lt;p&gt;In Rust, the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; type encapsulates two other types
like &lt;span class=&quot;code&quot;&gt;Either.&lt;/span&gt; A single &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt; value has either one of those types or the other:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/ok-or-err.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Instead of &lt;span class=&quot;code&quot;&gt;Left a&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;Right
b&lt;/span&gt; like in Haskell, Rust uses the words &lt;span class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; value is &lt;span
class=&quot;code&quot;&gt;Ok&lt;/span&gt;, then it contains an inner value of type &lt;span
class=&quot;code&quot;&gt;T&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;.
&lt;span class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt; means some operation was successful, and the
result of the operation is a value of type &lt;span class=&quot;code&quot;&gt;T&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value is &lt;span
class=&quot;code&quot;&gt;Err,&lt;/span&gt; then it contains an inner value of type &lt;span
class=&quot;code&quot;&gt;E&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt;
Similarly, this means the operation was a failure, and the result of the
operation is an error of type &lt;span class=&quot;code&quot;&gt;E&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Back to my open file example, the proper way to open a file and read it using
Rust is to check the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; values returned by the
Rust standard library functions:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(file) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;I have a file: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, file),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;There was an error: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;And If I want to actually read in the contents of that file, I would check that
return value also:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Ok(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;The file&amp;#39;s contents are: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, contents),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;There was an error: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;There was an error: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;The ? Operator In Rust&lt;/h2&gt;
&lt;p&gt;That last code snippet is quite a mouthful - error checking with Rust is even
more tedious and verbose than it is using Go!&lt;/p&gt;
&lt;p&gt;Fortunately, Rust includes an operator that allows Rust programmers to
abbreviate all of this logic. By appending the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt;
character to the call site of a function that returns a &lt;span
class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; value, Rust automatically generates code
that checks the &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; value, and returns
underlying &lt;span class=&quot;code&quot;&gt;T&lt;/span&gt; value if the result is &lt;span
class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here, the use of &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; after &lt;span
class=&quot;code&quot;&gt;File::open(&amp;quot;foo.txt&amp;quot;)&lt;/span&gt; tells the Rust compiler to check the
return value of &lt;span class=&quot;code&quot;&gt;File::open&lt;/span&gt; for me automatically:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/success-or-failure.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;If the return value of &lt;span class=&quot;code&quot;&gt;File::open&lt;/span&gt; is &lt;span
class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;, then Rust assigns the inner &lt;span
class=&quot;code&quot;&gt;T&lt;/span&gt; value to &lt;span class=&quot;code&quot;&gt;file&lt;/span&gt;. If &lt;span
class=&quot;code&quot;&gt;File::open&lt;/span&gt; returns &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt;, then
Rust jumps to the end of the &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt; function
immediately and returns.&lt;/p&gt;
&lt;p&gt;The program above is much more concise and easy to understand. The only problem
is that it doesn’t work! When I try to compile this, I get:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option`
(or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:20
  |
5 |     let mut file = File::open(&quot;foo.txt&quot;)?;
  |                    ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in
  a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
&lt;/pre&gt;
&lt;h2&gt;Rust Programs Revolve Around Error Handling&lt;/h2&gt;
&lt;p&gt;As the error message says, the problem here is that the &lt;span
class=&quot;code&quot;&gt;?&lt;/span&gt; operator generates code that will jump to the end of the
main function and return the &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt; value, where E is
of type &lt;span class=&quot;code&quot;&gt;std::io::Error&lt;/span&gt;. The problem is that I haven’t
declared a return value for &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt;. Therefore the Rust
compiler gives me an error:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
the `?` operator can only be used in a function that returns `Result` or
`Option` (or another type that implements `std::ops::Try`)
&lt;/pre&gt;
&lt;p&gt;The function containing the use of the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; operator has
to return a value of type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; with a
matching &lt;span class=&quot;code&quot;&gt;E&lt;/span&gt; type in order for this to make sense. I
have to extract my &lt;span class=&quot;code&quot;&gt;File&lt;/span&gt; calls into a separate
function, like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;read&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;String, std::io::Error&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(contents)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;read() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Note the new &lt;span class=&quot;code&quot;&gt;read()&lt;/span&gt; function above returns a value of
type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;String, std::io::Error&amp;gt;&lt;/span&gt;. This allows the
use of the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; operator to compile properly. For the
happy path, if my code is able to find the “foo.txt” file and read it, then
&lt;span class=&quot;code&quot;&gt;read()&lt;/span&gt; returns &lt;span
class=&quot;code&quot;&gt;Ok(contents)&lt;/span&gt;. However, if there’s an error, &lt;span
class=&quot;code&quot;&gt;read()&lt;/span&gt; will return &lt;span class=&quot;code&quot;&gt;Err(e)&lt;/span&gt;, where
&lt;span class=&quot;code&quot;&gt;e&lt;/span&gt; is a value of type &lt;span
class=&quot;code&quot;&gt;std::io::Error&lt;/span&gt;. Note &lt;span class=&quot;code&quot;&gt;open&lt;/span&gt; returns
the same error type that &lt;span class=&quot;code&quot;&gt;read&lt;/span&gt; does:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/error-types.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;This is where Rust shines. It allows for concise and readable error handling
that is also thorough and correct. The Rust compiler checks for error handling
completeness at &lt;em&gt;compile time&lt;/em&gt;, before I ever run my program.&lt;/p&gt;
&lt;p&gt;Now that I’ve learned some vocabulary words, now that I can understand how
native Rust speakers use the word &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;, I
can have a Rust conversation about error handling. I can begin to think like
Rust developers think. I can start to see things from their perspective.&lt;/p&gt;
&lt;p&gt;And I begin to realize that Rust programs tend to be designed with error
handling in mind. Notice above how I had to extract a separate function that
returned a value of type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;, just
because of the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; operator. The overall structure of
my program is determined by error handling just as much as it’s determined by
the nature of the task I’m trying to accomplish. Rust programmers think about
errors and what might go wrong from the very beginning, from when they start
writing code. To be honest, I've often thought about errors and what might go
wrong as an afterthought, after I've written and deployed my code.&lt;/p&gt;
</content></entry><entry><title>Using Rust to Build a Blog Site</title><link href="http://patshaughnessy.net/2019/9/4/using-rust-to-build-a-blog-site" rel="alternate"></link><id href="http://patshaughnessy.net/2019/9/4/using-rust-to-build-a-blog-site" rel="alternate"></id><published>2019-09-04T00:00:00Z</published><updated>2019-09-04T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/9/4/batteries.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Rust comes with batteries included&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Neo-Geo-Pocket-Color-w-batteries.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;After “Hello World,” blog sites a</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/9/4/batteries.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Rust comes with batteries included&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Neo-Geo-Pocket-Color-w-batteries.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;After “Hello World,” blog sites are the world’s second most unneeded
application. If you want to write a blog, use Medium, Wordpress or just
Twitter. The world doesn’t need another blog app.&lt;/p&gt;
&lt;p&gt;However, like Hello World, building a static site generator is a great way to
get your feet wet in a new programming language. Recently I rewrote &lt;a href=&quot;https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/src/lib.rs&quot;&gt;the script
I use to generate this web
site&lt;/a&gt;
using Rust: I needed to update and fix my script, but really I was looking for
an excuse to write Rust.  Despite its reputation as a difficult to learn,
expert level language,  Rust turned out to be a great choice for the simple
task of generating a few HTML files, quickly and reliably. Why? Not because of
its sophisticated borrow checker or support for safe concurrency.&lt;/p&gt;
&lt;p&gt;Rust was a great choice for me because I didn’t have to write most of the code.
Rust’s dependency management and build tool,
&lt;a href=&quot;https://doc.rust-lang.org/book/ch01-03-hello-cargo.html&quot;&gt;Cargo&lt;/a&gt;, allowed me to
glue together open source Rust libraries called “crates” which do most of the
work. The Rust community’s crate registry, &lt;a href=&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt;, has
over 29,000 crates available.  Downloading, compiling and using them is dead
simple. And writing a blog site using Rust turned out to be simple too.&lt;/p&gt;
&lt;h2&gt;My Cargo.toml File&lt;/h2&gt;
&lt;p&gt;I needed a few important features to generate this web site. I wanted my script
to work like this for each blog post:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/9/4/flowchart.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;For each blog post, My new Rust script had to: parse the markdown source file
and convert it to HTML markup, highlight the syntax of my code snippets using
&amp;lt;style&amp;gt; tags and CSS, and use a template to insert the HTML for each post
into the surrounding web layout/design. Sounds like a lot of work, right?&lt;/p&gt;
&lt;p&gt;Wrong. Other Rust developers smarter than me had already implemented all of
this. All I had to do was find the crates I needed and add them to my
Cargo.toml file:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
[dependencies]
maud = &quot;*&quot;
pulldown-cmark = &quot;*&quot;
syntect = &quot;3.0&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/raphlinus/pulldown-cmark&quot;&gt;Pulldown-cmark&lt;/a&gt; is a markdown
parser crate, &lt;a href=&quot;https://github.com/trishume/syntect&quot;&gt;Syntect&lt;/a&gt; is a color syntax
highlighting crate, and &lt;a href=&quot;https://github.com/lfairy/maud&quot;&gt;Maud&lt;/a&gt; is an HTML
template crate. Actually, to be honest I ended up adding a few other crates to
get my script to work:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
[dependencies]
maud = &quot;\*&quot;
pulldown-cmark = &quot;\*&quot;
regex = &quot;\*&quot;
lazy_static = &quot;\*&quot;
syntect = &quot;3.0&quot;
chrono = &quot;\*&quot;
clap = &quot;\*&quot;
ordinal = &quot;\*&quot;
&lt;/pre&gt;
&lt;p&gt;I’m not sure why, but the Rust standard library is very minimal. Features that
are included in other languages, like regular expressions or date/time parsing,
are handled by crates (e.g. regex and chrono).&lt;/p&gt;
&lt;p&gt;In any case, all I had to do was build my project and Cargo downloaded
everything I needed:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
$ cargo build --release
    Updating crates.io index
  Downloaded chrono v0.4.7
  Downloaded clap v2.33.0
  Downloaded maud v0.19.0
  Downloaded lazy_static v1.2.0
  Downloaded pulldown-cmark v0.2.0
  Downloaded ordinal v0.2.2
  Downloaded regex v1.1.0
  Downloaded syntect v3.0.2
  Downloaded libc v0.2.44
  Downloaded num-integer v0.1.41
  Downloaded num-traits v0.2.8
  Downloaded time v0.1.42

etc…
   Compiling syntect v3.0.2
   Compiling blogc v0.1.0 (/Users/pat/apps/patshaughnessy.github.io)
    Finished release [optimized] target(s) in 2m 27s
&lt;/pre&gt;
&lt;p&gt;It couldn’t be easier! During the rest of this post, I’ll show you how I used
these three crates: Pulldown-cmark, Syntect and Maud.&lt;/p&gt;
&lt;h2&gt;Pulldown-cmark&lt;/h2&gt;
&lt;p&gt;Now that my blog app included the Pulldown-mark crate, using it was just a
matter of pasting in a few of lines of code from the &lt;a href=&quot;https://docs.rs/pulldown-cmark/0.5.3/pulldown_cmark/html/fn.push_html.html&quot;&gt;helpful example on
docs.rs&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; parser &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Parser::new(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;markdown);
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;html::push_html(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html, parser);
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The first line created a &lt;span class=&quot;code&quot;&gt;Parser&lt;/span&gt; struct, passing in a
reference to my markdown string. Then I created an empty, mutable target
string, called &lt;span class=&quot;code&quot;&gt;html&lt;/span&gt;. Last, I called the &lt;span
class=&quot;code&quot;&gt;push_html&lt;/span&gt; function which parsed the markdown source,
converted it to HTML and saved it into &lt;span class=&quot;code&quot;&gt;html&lt;/span&gt;. I didn’t
have to do any work whatsoever.&lt;/p&gt;
&lt;p&gt;In fact, the only real work for me had to do with “header” strings present at
the top of each post source file. For example, the
&lt;a href=&quot;https://raw.githubusercontent.com/patshaughnessy/patshaughnessy.github.io/master/posts/2017-12-15-looking-inside-postgres-at-a-gist-index.markdown&quot;&gt;2017-12-15-looking-inside-postgres-at-a-gist-index.markdown&lt;/a&gt;
file starts with:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
title: &quot;Looking Inside Postgres at a GiST Index&quot;
date: 2017/12/15
tag: the Postgres LTREE Extension

etc…
&lt;/pre&gt;
&lt;p&gt;Here the first three lines are metadata values about the post and not part of
the post content. So before calling Pulldown-mark, my script parses and
removes these header lines:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;other_lines&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(lines: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Vec&amp;lt;String&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  lines.iter().skip_while(|l| is_header(l)).map(|l| l.to_string()).collect()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Above the &lt;span class=&quot;code&quot;&gt;lines&lt;/span&gt; parameter is an array of strings,
each a single line of text in the markdown source file. (More precisely, it’s a
reference to a &lt;span class=&quot;code&quot;&gt;Vec&amp;lt;String&amp;gt;&lt;/span&gt;, not an array.) The code
is fairly readable: &lt;span class=&quot;code&quot;&gt;other_lines&lt;/span&gt; creates an iterator
over the lines, skips the first few header lines, and then collects the
remaining lines into a second array which the function returns.&lt;/p&gt;
&lt;p&gt;Here’s the complete &lt;span class=&quot;code&quot;&gt;html_from_markdown&lt;/span&gt; function,
which calls &lt;span class=&quot;code&quot;&gt;other_lines&lt;/span&gt;, joins them together into a
single large string, and then passes that to Pulldown-mark:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;html_from_markdown&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(lines: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Vec&amp;lt;String&amp;gt;) -&amp;gt; Result&amp;lt;String, InvalidPostError&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; markdown &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; line &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;other_lines(lines) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    markdown.push_str(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;line);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    markdown.push(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; parser &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Parser::new(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;markdown);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  html::push_html(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html, parser);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  Ok(with_delim_removed(with_highlighted_code_snippets(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;html)))
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Syntect&lt;/h2&gt;
&lt;p&gt;If you read the code above carefully, you’ll notice &lt;span
class=&quot;code&quot;&gt;html_from_markdown&lt;/span&gt; calls &lt;span
class=&quot;code&quot;&gt;with_highlighted_code_snippets&lt;/span&gt; before returning the HTML
for each post. This function performs color syntax highlighting.&lt;/p&gt;
&lt;p&gt;The code snippets in each of my blog posts appear inside of &amp;lt;pre&amp;gt;…&amp;lt;/pre&amp;gt;
tags.  And I use a “type” attribute to indicate the programming language of the
snippet. For example:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
&amp;lt;pre type=&quot;ruby&quot;&gt;
puts &quot;This is Ruby code I’m writing about…&quot;
&amp;lt;/pre&gt;
&lt;/pre&gt;
&lt;p&gt;Like parsing markdown, syntax highlighting is a very complex task: The Syntect
crate has to parse the given code snippet, determine the semantic meaning of
each keyword in the snippet based on the provided programming language, and
then insert the proper color information. Thank goodness I didn’t have to write
that code!&lt;/p&gt;
&lt;p&gt;But using Syntect was easy:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;pub fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;highlighted_html_for_language&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(snippet: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String, attributes: String) -&amp;gt; String {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  lazy_static! {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: SyntaxSet &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SyntaxSet::load_from_folder(syntax_path()).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: Theme &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;ThemeSet::get_theme(theme_path().as_path()).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUBY_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;&amp;#39;static&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; SyntaxReference &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.find_syntax_by_extension(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rb&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUST_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;&amp;#39;static&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; SyntaxReference &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.find_syntax_by_extension(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rs&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ruby&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUBY_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  } &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rust&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUST_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;First I used a &lt;span class=&quot;code&quot;&gt;lazy_static&lt;/span&gt; block to initialize a few
constant values.
(&lt;a href=&quot;https://github.com/rust-lang-nursery/lazy-static.rs&quot;&gt;lazy_static&lt;/a&gt; is another
crate I didn’t have to write!) Rust executes this block once the first time
it’s encountered and then never again. The values are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;SYNTAX_SET&lt;/span&gt;: These are the Sublime syntax files
describing each programming language I need to colorize. vim is my editor,
but I use Sublime for color syntax highlighting :) I just downloaded these
files for the languages I needed and checked them into my app.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;THEME&lt;/span&gt;: These are the Sublime “theme” files, which
select the colors to use for each type of code keyword. I found and adapted
one of these files. They play the role of a CSS file, but use XML syntax.
Weird, but not hard to figure out.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;RUBY_SYNTAX&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;RUST_SYNTAX&lt;/span&gt;,
etc. The lazy block also looks up the syntax language file for each language.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Later my &lt;span class=&quot;code&quot;&gt;highlighted_html_for_language&lt;/span&gt; function
checks which programming language my post displays, and calls &lt;span
class=&quot;code&quot;&gt;syntect::html::highlighted_html_for_string&lt;/span&gt; with the proper
values:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ruby&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUBY_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  } &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rust&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUST_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&quot;code&quot;&gt;attributes&lt;/span&gt; is the array of HTML attributes from the
&amp;lt;pre&amp;gt; tag surrounding the code snippet in my post source. My app uses
regular expressions to find the &amp;lt;pre&amp;gt;…&amp;lt;/pre&amp;gt; HTML blocks, parses the
attributes and provides them to &lt;span
class=&quot;code&quot;&gt;highlighted_html_for_language&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Maud&lt;/h2&gt;
&lt;p&gt;Now my script has HTML for each blog post. All I have to do now is save it in a
series of HTML files. But first I needed a template engine for Rust, like ERB
for Ruby or Mustache for node.js.&lt;/p&gt;
&lt;p&gt;This turned out to be one of the most fun parts of this project. I rewrote &lt;a href=&quot;https://github.com/patshaughnessy/patshaughnessy.github.io/tree/master/src/layout&quot;&gt;my
HTML
markup&lt;/a&gt;
using Maud &lt;span class=&quot;code&quot;&gt;@&lt;/span&gt; directives, like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if let &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Some(&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;ref&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; t) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; post.tag {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  div class&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;header&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;More on &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(t)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  div class&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;links&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ul {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(link_url, link_title) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; recent_links {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        li {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          a href&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{ &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(link_url) } {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            (link_title)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Maud doesn’t parse the layout code at runtime, like ERB does in Ruby. Instead,
the &lt;span class=&quot;code&quot;&gt;@if&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;@for&lt;/span&gt; directives
above are macros. In fact, all of the HTML elements that appear above, like
&lt;span class=&quot;code&quot;&gt;div&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;ul&lt;/span&gt;, are macros
also. This means my Maud layout code is actually Rust code!  And that means the
Rust compiler will check it and make sure it’s valid before it ever runs.&lt;/p&gt;
&lt;p&gt;Converting my old ERB templates into Rust macros was a bit tedious, but it was
a great way to review and clean up my HTML. In fact, I found a number of
mistakes and errors in my HTML code that had been there for 10 years or longer.
It was like showing my dirty laundry to the Rust compiler. By the time the
compiler was done and let me compile my layout, it was very clean!&lt;/p&gt;
&lt;h2&gt;What It Worth It?&lt;/h2&gt;
&lt;p&gt;It took me several months on a spare time basis - an hour here an hour there -
to rewrite my blog in Rust. An experienced Rust developer working full time
could have done it in a day or two probably.&lt;/p&gt;
&lt;p&gt;What did I get for all this effort? Now I have a script that compiles all 146
of my markdown posts very quickly. My old Ruby script took 7.7 seconds to do
this, while the new Rust script only takes 0.28 seconds! That’s over 27 times
faster! In fact, the Rust code is so fast at parsing and compiling the markdown
files that I don’t check which files need to be recompiled by comparing
timestamps, i.e. what a Makefile would do during a build process. And I don’t
process the posts in parallel. Why bother? By the time I pressed ENTER and
looked up Rust was almost done building all 146 files in sequence, one after
the other.&lt;/p&gt;
&lt;p&gt;But what else did I get? The biggest improvement to my blog script, actually,
wasn’t the performance. It was the error handling I added. I didn’t mention
this above, but using the Rust standard library required me to use the
&lt;span class=&quot;code&quot;&gt;Result&amp;lt;T&amp;gt;&lt;/span&gt; generic type. This, in turn, forced me to
think about what might go wrong and what to do when it did go wrong. I’ll cover
this in my next article.  I ended up with a script that was much more reliable
and resilient to silly mistakes in my source files, and that gave me helpful
error messages… all the while running 27 times faster.&lt;/p&gt;
&lt;p&gt;However, the biggest benefit to rewriting my blog in Rust was that I clawed my
way up the Rust learning curve a bit. But that wouldn’t have been possible
without crates.io and Cargo. Using code from smarter, more seasoned Rust
developers gave me a chance to build a useful app, even as a beginner. Cargo
found, downloaded and compiled open source code from experts with just a few
simple commands.&lt;/p&gt;
</content></entry><entry><title>Summer School With The Rust Compiler</title><link href="http://patshaughnessy.net/2018/10/24/summer-school-with-the-rust-compiler" rel="alternate"></link><id href="http://patshaughnessy.net/2018/10/24/summer-school-with-the-rust-compiler" rel="alternate"></id><published>2018-10-24T00:00:00Z</published><updated>2018-10-24T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/10/24/steves-tweet.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(source: &lt;a href=&quot;https://twitter.com/steveklabnik/status/1022518806814617601&quot;&gt;Steve Klabnik via Twitter&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;A few months ago, I saw this tweet from Steve. I'm not even sure what
&amp;quot;derridean</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/10/24/steves-tweet.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(source: &lt;a href=&quot;https://twitter.com/steveklabnik/status/1022518806814617601&quot;&gt;Steve Klabnik via Twitter&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;A few months ago, I saw this tweet from Steve. I'm not even sure what
&amp;quot;derridean&amp;quot; means, but now the image of an insane coach pops into my head every
time I try to write Rust code.&lt;/p&gt;
&lt;p&gt;Learning Rust is hard for everyone, but it’s even worse for me because I’ve
been working with Ruby during past ten years. Switching to Rust from Ruby is
leaving an anything-goes hippie commune to a summer school for delinquent
programmers run by a sadistic and unforgiving teacher.&lt;/p&gt;
&lt;p&gt;Why would anyone use a compiler like this? The answer is simple: to learn how
to write better code. This past summer I had some free time and decided to
convert a simple Ruby script into Rust. As you’ll see, the Rust compiler beat
me up a few times; it wasn’t easy. But after some tough love I ended up
learning something, not only about Rust but about Ruby too.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Iterating Over an Array in Ruby&lt;/h2&gt;
&lt;p&gt;Here’s my example program. It’s so short and simple you can read and understand
it in just a few seconds:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts i
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;When I ran it, the output was:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby int-loop.rb
1
2
3
&lt;/pre&gt;
&lt;div style=&quot;float: right; padding: 70px 0px 30px 30px; text-align: center;&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/10/24/garden-earthly-delights.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;&lt;small&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Garden_of_Earthly_Delights&quot;&gt;The Garden of Earthly Delights&lt;/a&gt; (detail), by Hieronymus Bosch&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Ruby’s syntax and feature set are designed to make my life easier as a
developer.  Writing Ruby for me is as natural as writing English; it’s like
having a pleasant conversation with my computer. I’m living in the Garden of
Earthly Delights. If I can imagine a code change, I can write it. Using Ruby,
all of my dreams can come true.&lt;/p&gt;
&lt;p&gt;Next I decided to increment the values before printing them out. I added just
one line of code to my example, &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts i
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As I expected, Ruby printed out 2 through 4:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby int-loop.rb
2
3
4
&lt;/pre&gt;
&lt;p&gt;Of course, there are other ways to produce the same result. I could have used
&lt;span class=&quot;code&quot;&gt;puts i+1&lt;/span&gt;, or mapped the original array to a new array
&lt;span class=&quot;code&quot;&gt;[2, 3, 4]&lt;/span&gt;. But Ruby doesn’t care. Today I felt like
writing &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt;, and Ruby let me do it without
comment. Ruby is the parent of an unruly teenager that gets away with anything.&lt;/p&gt;
&lt;p&gt;As I found out later, using &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; might have broken
a Computer Science rule or two, but I was blissfully unaware. What you don’t
know can’t hurt you. Ruby didn’t tell me anything might be wrong… but as we’ll
see Rust certainly did!&lt;/p&gt;
&lt;h2&gt;Rust: Similar to Ruby At First Glance&lt;/h2&gt;
&lt;p&gt;I was curious: What would the Rust compiler think of this example? I was able
to rewrite it in only a few minutes:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;I had to type semicolons after each line and use a &lt;span
class=&quot;code&quot;&gt;main&lt;/span&gt; function. A bit more typing, but really this is
exactly the same program. Running this, of course, produced the same result:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
1
2
3
&lt;/pre&gt;
&lt;p&gt;Then I decided to try using the same &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; line from above:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Lesson One: Passing By Reference vs. Passing By Value&lt;/h2&gt;
&lt;p&gt;Compiling this, the Rust compiler hit me over the head with Computer Science!&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
error[E0271]: type mismatch resolving `&lt;&amp;i32 as std::ops::Add&lt;i32&gt;&gt;::Output == &amp;i32`
  --&gt; int-loop.rs:4:14
   |
 4 |         i = i+1;
   |              ^ expected i32, found &amp;i32
   |
   = note: expected type `i32`
              found type `&amp;i32`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0271`.
&lt;/pre&gt;
&lt;p&gt;What in the world does this mean? I wrote a very simple line of code, and got a
message straight out of type theory! The error &lt;span class=&quot;code&quot;&gt;type mismatch
resolving `&amp;lt;&amp;amp;i32 as std::ops::Add&amp;gt;::Output == &amp;amp;i32`&lt;/span&gt; makes no sense to me at
all.&lt;/p&gt;
&lt;p&gt;I decided to take the compiler’s suggestion and run the explain command:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc --explain E0271
This is because of a type mismatch between the associated type of some
trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)
and another type `U` that is required to be equal to `T::Bar`, but is not.
Examples follow.
&lt;/pre&gt;
&lt;p&gt;The explain output continued for about two more pages, with examples that
didn’t resemble my code at all. What is a trait? What is an associated type? I
didn’t use any of these more advanced Rust concepts in my simple script. Maybe
I needed a PhD. in Computer Science even to try to use Rust?&lt;/p&gt;
&lt;p&gt;Eventually, I figured it out. The key lines from the error message were:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
 4 |         i = i+1;
   |              ^ expected i32, found &amp;i32
&lt;/pre&gt;
&lt;p&gt;Rust is telling me that &lt;span class=&quot;code&quot;&gt;iter()&lt;/span&gt; yielded references to
integers, but my code expected an actual integer, not a reference to an
integer. But what are references, exactly?&lt;/p&gt;
&lt;p&gt;Running my code above, Ruby passed each integer from the array to my code as a
simple value:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;185&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/ruby-passes-by-value.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But Rust passed each integer from the array as a reference, or in other words
as a pointer to the value itself:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;287&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/rust-passes-by-reference.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In Ruby, of course, I didn’t have to worry about references, pointers or even
types, so none of this came up. Or at least that’s what I thought at the time.&lt;/p&gt;
&lt;h2&gt;Lesson Two: Borrowed Values&lt;/h2&gt;
&lt;p&gt;Ah - according to the Rust compiler’s error message I just had to dereference
the reference before using it. I changed &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; to
&lt;span class=&quot;code&quot;&gt;*i = *i+1&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Then Rust slapped me in the face again with more Computer Science:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
error[E0594]: cannot assign to immutable borrowed content `*i`
  --&gt; int-loop.rs:26:9
   |
26 |         *i = *i+1;
   |         ^^^^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0594`.
&lt;/pre&gt;
&lt;p&gt;Ugh. I guess that was a bad idea. What in the world happened here? I thought I
had the dereferencing syntax correct, &lt;span class=&quot;code&quot;&gt;*i&lt;/span&gt;, the same
syntax I’m used to from C.  Actually Rust didn’t complain about types any more
or about using a reference vs. a value. But what does “borrow as mutable” mean?
And why doesn’t Rust let me do that?&lt;/p&gt;
&lt;p&gt;Again, the problem here is that I don’t know enough Rust even to understand the
compiler’s error messages. I need to take a few months off from my day job and
read a book, or take a class. I need to understand Rust’s ownership model.&lt;/p&gt;
&lt;p&gt;In Rust, every value is “owned” by the spot in my code where I allocate that
value. In this example, the integers and the array that contains them are owned
by the &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt; function. When the &lt;span
class=&quot;code&quot;&gt;main&lt;/span&gt; function goes out of scope, Rust frees the memory for
that array automatically. In this diagram, the red arrow shows where Rust
allocates the array (at the top), and where Rust frees it (at the bottom):&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;339&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/rust-lifetime.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You can think of the red arrow as the “lifetime” of the array. When I pass a
value from one spot to another, when I call a function or a closure, I can
either “move” that value to the new function, or the function can ”borrow” it.
In this example, the call to &lt;span class=&quot;code&quot;&gt;iter()&lt;/span&gt; borrowed the
elements inside the array, passing a reference to each element into the
closure. The blue array in this diagram indicates each element of the array,
&lt;span class=&quot;code&quot;&gt;i&lt;/span&gt;, is a borrowed value inside the closure:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;334&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/rust-borrow.png&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Lesson Three: Immutable vs. Mutable Values&lt;/h2&gt;
&lt;p&gt;But using borrowed values isn’t the problem here. The problem is that my code
tries to change them, or mutate them:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Because the value of &lt;span class=&quot;code&quot;&gt;i&lt;/span&gt; each time around the loop was
an element of the array, and because &lt;span class=&quot;code&quot;&gt;iter()&lt;/span&gt; borrowed
each element from the original array, the elements are marked as immutable,
just as the array was. Or at least I that’s how I understood the previous error
message.&lt;/p&gt;
&lt;p&gt;Back in the &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt; function when I typed:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;…Rust created an immutable array of three integers. All variables in Rust are
immutable by default. Because it was immutable, my code can’t change it.&lt;/p&gt;
&lt;p&gt;Ah… so the fix is to mark my array as mutable:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Lesson Four: Declaring Side Effects&lt;/h2&gt;
&lt;p&gt;Running the Rust compiler again, I got the same error along with a new warning:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
error[E0594]: cannot assign to immutable borrowed content `*i`
  --&gt; int-loop.rs:14:9
   |
14 |         *i = *i+1;
   |         ^^^^^^^^^ cannot borrow as mutable

warning: variable does not need to be mutable
  --&gt; int-loop.rs:12:9
   |
12 |     let mut array = [1, 2, 3];
   |         ----^^^^^
   |         |
   |         help: remove this `mut`
   |
&lt;/pre&gt;
&lt;p&gt;Wait - so now Rust was telling me I shouldn’t add the &lt;span
class=&quot;code&quot;&gt;mut&lt;/span&gt; keyword? That my last change was dead wrong? Why was it
wrong? Probably I didn’t understand what “cannot borrow as mutable” really
meant.&lt;/p&gt;
&lt;p&gt;It took me a while to figure this out but eventually I ran into this &lt;a href=&quot;https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html&quot;&gt;great
article&lt;/a&gt;
which explained what I was doing wrong and how to fix it. I needed to use
&lt;span class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; instead of &lt;span class=&quot;code&quot;&gt;iter&lt;/span&gt;. &lt;span
class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; yields mutable references to the closure, while
&lt;span class=&quot;code&quot;&gt;iter&lt;/span&gt; yields normal, immutable references.&lt;/p&gt;
&lt;p&gt;That is, by calling &lt;span class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; I’m declaring that the
code inside of the closure might mutate the elements of the array. This is
knowns as a &lt;em&gt;side effect&lt;/em&gt;. As a side effect of the iteration, the code inside
might also change the values of the collection it is iterating over. Rust
forced me to declare that my code might change the array.&lt;/p&gt;
&lt;p&gt;Finally, running my program with &lt;span class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; finally worked!&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter_mut() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
2
3
4
&lt;/pre&gt;
&lt;h2&gt;What Rust Taught Me&lt;/h2&gt;
&lt;p&gt;My example today started out as a trivial, 4 line Ruby script. It was so
simple, there really wasn’t anything that could possibly go wrong when I ran
it. Then I added one simple line of code: i = i+1. When I added this to my Ruby
script, it worked just fine.&lt;/p&gt;
&lt;p&gt;As we saw, this line of code got the Rust compiler very angry. It slapped me in
the face with four Computer Science lessons. I learned:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;about passing values vs. passing references.&lt;/li&gt;
&lt;li&gt;about mutable vs. immutable values.&lt;/li&gt;
&lt;li&gt;about value ownership, lifetimes and borrowing values.&lt;/li&gt;
&lt;li&gt;about side effects, and declaring them.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see, the Rust compiler is an amazing tool you can use to learn more
about Computer Science. The problem is that it’s hard to get along with.
Compiling a Rust program will fail over and over again until you your code is
100% correct. You need to have tremendous patience to use Rust, especially as a
beginner.&lt;/p&gt;
&lt;p&gt;Worse than that, the Rust compiler’s error messages are hard to understand, and
easy to misinterpret. They can seem to be self-contradictory as we saw above. The
Rust compiler assumes you already know what it is trying to teach you. Not only
is Rust a violent teacher, it’s a bad one. If I knew that &lt;span
class=&quot;code&quot;&gt;iter()&lt;/span&gt; borrowed immutable values, if I knew what
“borrowing” and “immutable” even meant, then I likely wouldn’t have run into
that compiler error in the first place.&lt;/p&gt;
&lt;p&gt;And Rust’s confusing error message lead me in the wrong direction. In this
example, I didn’t really want to mutate the array, I just wanted to print out
the incremented values. I could have just incremented an intermediate value and
left the original array alone. Instead, the complex error messages confused and
mislead me, and I never discovered this simpler code:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The Rust compiler is an amazing tool for learning; the problem is you need to
have a deep understanding of the Rust language before you can use it
effectively. Rust needs a --beginner option. Using this option on the
command line would intstruct the compiler to produce error messages designed
for Rust learners, rather than Rust experts.&lt;/p&gt;
&lt;h2&gt;What Ruby Didn’t Tell Me&lt;/h2&gt;
&lt;p&gt;I had the opposite experience using Ruby. No confusing compiler errors; in
fact, no compiler at all. No types, no need to worry about immutability or
whether I’m passing references or values. Everything just worked.&lt;/p&gt;
&lt;p&gt;Or did it? Because Ruby passed integers by value, the array in my original
example wasn’t modified:&lt;/p&gt;
&lt;pre&gt;
array = [1, 2, 3]
for i in array
  i = i+1
  puts i
end
puts &quot;----&quot;
p array
&lt;/pre&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby int-loop.rb
2
3
4
----
[1, 2, 3]
&lt;/pre&gt;
&lt;p&gt;This is probably a good thing. Side effects like mutating a collection while
iterating over it can easily lead to bugs. Maybe code later in my program
needed the original, unchanged values in that array? Maybe another thread was
trying to use that collection at the same time?&lt;/p&gt;
&lt;p&gt;The problem with using Ruby is that you don’t know what Ruby isn’t telling you.
Because Ruby didn’t display any warnings or error messages when I added &lt;span
class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; to my loop, I didn’t even think about any of these
issues. Fortunately, Ruby didn't modify the array so it wasn't a problem.&lt;/p&gt;
&lt;p&gt;But suppose my array contained strings and not integers:&lt;/p&gt;
&lt;pre&gt;
array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
for str in array
    str = str &lt;&lt; &quot;-mutated&quot;
    puts str
end
puts &quot;----&quot;
p array
&lt;/pre&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby string-loop.rb
one-mutated
two-mutated
three-mutated
----
[&quot;one-mutated&quot;, &quot;two-mutated&quot;, &quot;three-mutated&quot;]
&lt;/pre&gt;
&lt;p&gt;Now the array was mutated! It turns out Ruby passed integers to the closure by
value, but strings by reference. Updating each string inside the loop also
updated that string inside the array. Now my program will have bugs, unless the
point of running that loop was to mutate the array, and not just to print it
out.&lt;/p&gt;
</content></entry><entry><title>From ActiveRecord to Diesel</title><link href="http://patshaughnessy.net/2018/6/9/from-activerecord-to-diesel" rel="alternate"></link><id href="http://patshaughnessy.net/2018/6/9/from-activerecord-to-diesel" rel="alternate"></id><published>2018-06-09T00:00:00Z</published><updated>2018-06-09T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/exercise.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Learning something new every day
is exercise for your mind.&lt;/i&gt;&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Defender_builds_routine_to_achieve_goals_140716-F-FW757-073.jpg&quot;&gt;Jeremy Bowcock via Wikimedi</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/exercise.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Learning something new every day
is exercise for your mind.&lt;/i&gt;&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Defender_builds_routine_to_achieve_goals_140716-F-FW757-073.jpg&quot;&gt;Jeremy Bowcock via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;As software developers we’re paid to be professional learners. People hire us
(or should hire us) for what we are capable of learning, not for what we
already know. To stay in shape and keep up with our peers we need to practice
by learning something new every day. We need to get daily exercise for our
minds.&lt;/p&gt;
&lt;p&gt;For me the best way to do this is to make simple tasks harder. Many times each
day I need to copy files, parse XML, generate JSON, or send an HTTP request.
The boring daily chores of a modern knowledge worker. To make my life more
interesting and to exercise my mind, I sometimes choose new tools or
programming languages that are harder to use, not easier, to accomplish these
small tasks.&lt;/p&gt;
&lt;p&gt;Let’s take an example. Recently I needed to run a simple SQL query on a
Postgres database and produce a one-off report. I could have done this in 5
minutes using Ruby and ActiveRecord. Instead, I decided to use
&lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt; and &lt;a href=&quot;http://diesel.rs&quot;&gt;Diesel&lt;/a&gt; - a language
and a tool I hadn’t used before. Instead of 5 minutes it took several hours,
but I learned something new. I've written up the steps I took here today. Get
your mind’s exercise for today and read on to learn how to execute a SQL
statement using Rust.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;TL/DR&lt;/b&gt;: I posted &lt;a href=&quot;https://gist.github.com/patshaughnessy/db735e90d58376fdd550b35838aa5339&quot;&gt;the
code&lt;/a&gt;
from this article if you want to skip the explanation and just try it.&lt;/p&gt;
&lt;h2&gt;Running a SQL Query Using Ruby and ActiveRecord&lt;/h2&gt;
&lt;p&gt;My actual data set looked different, but suppose as an example I had a Postgres
table called &lt;span class=&quot;code&quot;&gt;users&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
create table users (
    id serial primary key,
    first_name varchar(40),
    last_name  varchar(40)
);
&lt;/pre&gt;
&lt;p&gt;…and I needed to count the number of users with multiple last names. People
from Spanish speaking countries, like my wife, often have two last names.
Because I was in a rush and had to get an answer quickly, I turned to
ActiveRecord. This simple Ruby script ran a SQL query and also a bit of Ruby
post-processing to find the number of users with multiple last names:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;user_groups &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;User&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.all.partition &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;user&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  user.last_name.split.size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Found &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{user_groups.first.size}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; users with more than one last name.&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Found &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{user_groups.last.size}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; users with one last name.&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Ruby and ActiveRecord worked brilliantly. I was done. Neither the language nor
the tools got in my way and I had the quick answer I needed. After just five
minutes I moved on to more important work.&lt;/p&gt;
&lt;h2&gt;Time to Exercise My Mind&lt;/h2&gt;
&lt;p&gt;I had a quick answer, but didn’t learn anything. I realized that if I spent all
of my time getting my work done as quickly as possible and never learned
anything new, I’d fall behind in the long run.&lt;/p&gt;
&lt;p&gt;Because this task was so simple, I decided to try to write the same report
using Rust instead of Ruby. But how? Rust is a much more complex, low level
language than Ruby is. How in the world could I learn about its type system,
its borrow checker, its compiler/build tools, its debugging tools and, of
course, its language syntax without spending months and months reading books?&lt;/p&gt;
&lt;p&gt;The answer was just to try it. And what better way to try a new language than
to work on a simple task like this. It was time for my daily exercise.&lt;/p&gt;
&lt;p&gt;First, I installed &lt;a href=&quot;https://www.rust-lang.org/en-US/install.html&quot;&gt;Rust&lt;/a&gt;, poked
around the &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/index.html&quot;&gt;The Rust Programming
Language&lt;/a&gt; book a bit,
and read the excellent &lt;a href=&quot;http://diesel.rs/guides/getting-started/&quot;&gt;Diesel
tutorial&lt;/a&gt;. Rust has great
documentation and getting up to speed with this extremely complex language is
just a matter of time, focus and attention. Then I rewrote that simple
Ruby/ActiveRecord report script above using Rust and Diesel. Here’s how I did
it.&lt;/p&gt;
&lt;h2&gt;A New Rust Project&lt;/h2&gt;
&lt;p&gt;To get started, I created a new Rust project using
&lt;a href=&quot;https://doc.rust-lang.org/cargo/guide/&quot;&gt;Cargo&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
$ cargo new last_names --bin
     Created binary (application) `last_names` project
$ cd last_names
$ cargo build
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)
    Finished dev [unoptimized + debuginfo] target(s) in 7.68 secs
$ target/debug/last_names
Hello, world!
&lt;/pre&gt;
&lt;p&gt;As you can see, Cargo got me started quickly, and I was able to print “Hello
World” with just a few commands.&lt;/p&gt;
&lt;p&gt;Cargo placed the source code in a Rust file called src/main.rs, which looks
like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/hello-world.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As a comparison, I show the equivalent Ruby code below in pink. Pretty simple.&lt;/p&gt;
&lt;h2&gt;From Gemfile to Cargo.toml&lt;/h2&gt;
&lt;p&gt;I knew my script needed to connect to Postgres and execute a SQL statement, so
I added Diesel as a dependency to my Cargo.toml file:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/cargo-toml.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Cargo is a dependency manager similar to Ruby’s &lt;a href=&quot;https://bundler.io&quot;&gt;Bundler&lt;/a&gt;.
The Cargo.toml file lists the Rust libraries, or “crates,” that my script will
use. It plays the same role as the Gemfile does for Ruby projects.&lt;/p&gt;
&lt;p&gt;Then I installed Diesel by running “cargo build” again:&lt;/p&gt;
&lt;pre&gt;
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading diesel v1.3.0
 Downloading pq-sys v0.4.5

etc…

  Compiling diesel_derives v1.3.0
   Compiling diesel v1.3.0
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)
    Finished dev [unoptimized + debuginfo] target(s) in 47.30 secs
&lt;/pre&gt;
&lt;h2&gt;Connecting to Postgres&lt;/h2&gt;
&lt;p&gt;Ok now I’m ready to start working on my report code, back in main.rs. The first
thing I need to do is open a connection to Postgres. After that, I can figure
out how to execute my report.&lt;/p&gt;
&lt;p&gt;Here’s how I did it - again I show the Rust code in grey and the equivalent
Ruby code below in pink:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/connect.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The Rust code is fairly simple and easy to understand: It just passes a
Postgres connection string to &lt;span
class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt;. One interesting and important
detail here is the call to &lt;span class=&quot;code&quot;&gt;expect&lt;/span&gt;. &lt;span
class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt; returns a &lt;span
class=&quot;code&quot;&gt;ConnectionResult&lt;T&gt;&lt;/span&gt; value, which is derived from the
&lt;a href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html&quot;&gt;Result enum&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;200&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/result.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As &lt;em&gt;The Rust Programming Language&lt;/em&gt;
&lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html&quot;&gt;explains&lt;/a&gt;,
&lt;span class=&quot;code&quot;&gt;expect&lt;/span&gt; checks whether the result value contains &lt;span
class=&quot;code&quot;&gt;Ok&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;Err&lt;/span&gt;. If it contains &lt;span
class=&quot;code&quot;&gt;Err&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;expect&lt;/span&gt; prints out the given
error message.&lt;/p&gt;
&lt;p&gt;Assuming my Postgres server is up and running and contains a database called
“names,” I can now compile, run my Rust script and connect to Postgres:&lt;/p&gt;
&lt;pre&gt;
$ cargo build
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)
    Finished dev [unoptimized + debuginfo] target(s) in 0.71 secs
$ target/debug/last_names
Connected!
&lt;/pre&gt;
&lt;p&gt;Stepping back for a moment, the Ruby and Rust versions of this code are
actually very similar. However, the Rust version is a bit more complex because
I have to explicitly handle the possibility that &lt;span
class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt; might return an error. In Ruby I
can ignore this possibility, although my script would crash if &lt;span
class=&quot;code&quot;&gt;ActiveRecord::Base.establish_connection&lt;/span&gt; ran into a problem
and raised an exception.&lt;/p&gt;
&lt;h2&gt;Inspecting My Postgres Column Types&lt;/h2&gt;
&lt;p&gt;Using Ruby, ActiveRecord automatically inspects my database table and creates
methods on my model class for each column. But in Rust, I have to type in code
that declares each Postgres table and column I plan to use. (Actually, Diesel
can also inspect my database columns automatically using the &lt;span
class=&quot;code&quot;&gt;infer_schema!&lt;/span&gt; macro, but as a beginner I find it easier to
type this information in explicitly.)&lt;/p&gt;
&lt;p&gt;Fortunately, Diesel provides a command line tool that makes this easy:&lt;/p&gt;
&lt;pre&gt;
$ diesel print-schema --database-url=postgres://pat@patshaughnessy.net:5432/names --whitelist users
table! {
    users (id) {
        id -&gt; Int4,
        first_name -&gt; Nullable&amp;lt;Varchar&gt;,
        last_name -&gt; Nullable&amp;lt;Varchar&gt;,
    }
}
&lt;/pre&gt;
&lt;p&gt;The diesel tool printed out a series of Rust macros that declare the name of my
Postgres table, and the names and types of each of the table’s columns. Notice
that I provided two command line parameters: the Postgres connection string and
my database table name.&lt;/p&gt;
&lt;p&gt;The Diesel macros resemble the original SQL definition of my Postgres table:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;676&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/sql-to-macro.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Diesel used &lt;span class=&quot;code&quot;&gt;Int4&lt;/span&gt; for the primary key column, and
&lt;span class=&quot;code&quot;&gt;Nullable&amp;lt;Varchar&amp;gt;&lt;/span&gt; for each of the Postgres varchar
string columns. &lt;span class=&quot;code&quot;&gt;Nullable&lt;/span&gt; must mean that my Postgres
SQL schema allows null values for &lt;span class=&quot;code&quot;&gt;first_name&lt;/span&gt; and
&lt;span class=&quot;code&quot;&gt;last_name&lt;/span&gt;. In other words, it means that I didn’t
specify &lt;span class=&quot;code&quot;&gt;NOT NULL&lt;/span&gt; for these columns in my
&lt;span class=&quot;code&quot;&gt;CREATE TABLE&lt;/span&gt; command.&lt;/p&gt;
&lt;h2&gt;Creating a Model&lt;/h2&gt;
&lt;p&gt;Next, using these macros as a guide, I wrote a Rust struct to serve as my
database model. An instance of this struct was going to represent each row in
my Postgres table:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;692&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/macro-to-model.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Just as Diesel mapped each Postgres column type to a Rust macro with the
corresponding type, I had to choose a Rust type for each Postgres column in my
new struct. For the id column, I picked Rust’s &lt;span class=&quot;code&quot;&gt;i32&lt;/span&gt;
integer type. This made sense because the &lt;span class=&quot;code&quot;&gt;Int4&lt;/span&gt;
implied a 4 byte or 32 bit integer value. And for each of the string columns, I
chose the Rust &lt;span class=&quot;code&quot;&gt;String&lt;/span&gt; type.&lt;/p&gt;
&lt;p&gt;Finally, I pasted all of this into my main.rs source code file, as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/model.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Reading this over, the Ruby version is much more concise. In Rust I specified
the name and type of each column, while in Ruby ActiveRecord figured all of
that out for me. (Although as I mentioned above, I could have asked Diesel to
detect the column types automatically also.)&lt;/p&gt;
&lt;h2&gt;Trying to Execute a SQL Statement in Rust&lt;/h2&gt;
&lt;p&gt;Now after all of this setup, I’m finally ready to execute my report. Here’s the
Rust code I wrote inside the &lt;span class=&quot;code&quot;&gt;main()&lt;/span&gt; function, following the call to
&lt;span class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/trying.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It took me a while to figure out the proper syntax, especially the bits that
use generic type notation, like &lt;span class=&quot;code&quot;&gt;Vec&amp;lt;User&amp;gt;&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt;. Also the &lt;span
class=&quot;code&quot;&gt;.collect::&amp;lt;Vec&amp;lt;&amp;amp;str&amp;gt;&amp;gt;()&lt;/span&gt; code seemed a bit odd to me as
well, because it includes a type inside a function name. The reason for this
complex notation is that the &lt;span class=&quot;code&quot;&gt;collect&lt;/span&gt; function
converts the iterator returned by &lt;span class=&quot;code&quot;&gt;split&lt;/span&gt; into an
array, but the Rust compiler needs to know what type of values will be in that
array. Rust normally uses type inference to figure this out, but in this case
there’s no way for it to know. Therefore, I needed to specify the &lt;span
class=&quot;code&quot;&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt; type manually, telling Rust I wanted an array of
string references.&lt;/p&gt;
&lt;p&gt;But in the end I was surprised how similar the Rust and Ruby versions of this
code are! Both load all the user records into memory in a similar way, although
the Rust version has to check for errors explicitly. And both Rust and Ruby use
&lt;span class=&quot;code&quot;&gt;partition&lt;/span&gt; with a closure that checks whether each
last name string contains multiple words or not, by calling &lt;span
class=&quot;code&quot;&gt;split&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;I was very excited to try this out, so I ran the Rust compiler:&lt;/p&gt;
&lt;pre&gt;
$ cargo build
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)

error[E0277]: the trait bound `*const str:
            diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, _&gt;`
            is not satisfied

  --&gt; src/main.rs:30:25
   |
30 |     let results = users.load::&amp;lt;User&gt;(&amp;connection).expect(
   |                         ^^^^ the trait
   |                              `diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Nullable
   |                              &amp;lt;diesel::sql_types::Text&gt;, _&gt;` is not implemented for `*const str`
   |
   = help: the following implementations were found:
             &amp;lt;*const str as diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Text, DB&gt;&gt;
             &amp;lt;*const [u8] as diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Binary, DB&gt;&gt;
   = note: required because of the requirements on the impl of `diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, _&gt;` for `std::string::String`
   = note: required because of the requirements on the impl of `diesel::Queryable&amp;lt;diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, _&gt;` for `std::string::String`
   = note: required because of the requirements on the impl of `diesel::Queryable&amp;lt;(diesel::sql_types::Integer, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;), _&gt;` for `(i32, std::string::String, std::string::String)`
   = note: required because of the requirements on the impl of `diesel::Queryable&amp;lt;(diesel::sql_types::Integer, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;), _&gt;` for `User`
   = note: required because of the requirements on the impl of `diesel::query_dsl::LoadQuery&amp;lt;_, User&gt;` for `users::table`

error: aborting due to previous error

error: Could not compile `last_names`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;
&lt;p&gt;Ugh - what happened? I started to realize how difficult error messages from the
Rust compiler can be to understand, especially for beginners like me.&lt;/p&gt;
&lt;p&gt;And I certainly didn’t want to try the “—verbose” option the Rust compiler
suggested. This message was already verbose enough!&lt;/p&gt;
&lt;h2&gt;Rust’s Type System Keeps Me Out of Trouble&lt;/h2&gt;
&lt;p&gt;After a while, I realized what the problem was. Reading the error message again
more carefully, I saw the line:&lt;/p&gt;
&lt;pre&gt;
diesel::sql_types::Nullable&lt;diesel::sql_types::Text&gt; ...is not satisfied
&lt;/pre&gt;
&lt;p&gt;Ah - the problem must have to do with the &lt;span class=&quot;code&quot;&gt;Nullable&lt;/span&gt;
macro the Diesel utility generated for me. That indicated that my underlying
Postgres column allowed null values. At first, I thought maybe I should add
&lt;span class=&quot;code&quot;&gt;NOT NULL&lt;/span&gt; to my Postgres table and prevent users with
null last names. That must be the answer.&lt;/p&gt;
&lt;p&gt;But thinking about this some more, I realized that maybe having no last name is
a valid state. That some people really don’t have last names… Bono, Lady Gaga,
or Sting. Or maybe these are their last names and they have no first names?
Either way it seemed to me that my report code should handle null values, and
that it shouldn’t make assumptions about what’s in the data set.&lt;/p&gt;
&lt;p&gt;I decided to adapt my Rust code to make this work, and to do that I needed a
way of saving null values in my User struct. The problem, what the Rust
compiler was trying to tell me, was that my User struct could not handle nulls
as written. I needed to use an option type instead:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;693&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/option-model.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Like the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; enum we saw above, &lt;span
class=&quot;code&quot;&gt;Option&lt;/span&gt; is an enum that can contain either &lt;span
class=&quot;code&quot;&gt;Some&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;None&lt;/span&gt;… i.e. a null value:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;170&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/option.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;To learn more about the &lt;span class=&quot;code&quot;&gt;Option&lt;/span&gt; type, read &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values&quot;&gt;Chapter
6&lt;/a&gt;
from &lt;em&gt;The Rust Programming Language&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;After changing my &lt;span class=&quot;code&quot;&gt;User&lt;/span&gt; struct, I then had to rework
the closure inside of &lt;span class=&quot;code&quot;&gt;partition&lt;/span&gt;. Here’s what I ended
up with:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/unwrap.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I wrote &lt;span class=&quot;code&quot;&gt;if let Some(ref name)&lt;/span&gt; to check whether or not
the last name of each user struct was null. In other words, I “unwrapped” the
last name. The &lt;span class=&quot;code&quot;&gt;ref&lt;/span&gt; keyword satisfies Rust’s borrow
checker, which enforces Rust’s unique and innovative memory ownership model.
Without &lt;span class=&quot;code&quot;&gt;ref&lt;/span&gt;, the Rust compiler would give me another
error: “cannot move out of borrowed content.” To learn more about Rust’s
ownership model, see &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch04-00-understanding-ownership.html&quot;&gt;Chapter
4&lt;/a&gt;
of &lt;em&gt;The Rust Programming Language&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Finally, I compiled and ran my Rust code, and saw the results I expected:&lt;/p&gt;
&lt;pre&gt;
$ target/debug/last_names
Connected!
Found 20 users with more than one last name.
Found 80 users with one last name.
&lt;/pre&gt;
&lt;p&gt;As a test, I tried adding a user with no last name and got the expected results - the
user with no last name was counted as if they had one:&lt;/p&gt;
&lt;pre&gt;
$ psql names
psql (9.6.3)
Type &quot;help&quot; for help.
names=# INSERT INTO users (first_name, last_name) VALUES ('Bono', NULL);
INSERT 0 1
names=# \q

$ target/debug/last_names
Connected!
Found 20 users with more than one last name.
Found 81 users with one last name.
&lt;/pre&gt;
&lt;p&gt;But when I reran my original Ruby code with a null last name, it crashed!&lt;/p&gt;
&lt;pre&gt;
$ ruby main.rb
Connected.
main.rb:18:in `block in \&lt;main\&gt;': undefined method `split' for nil:NilClass (NoMethodError)
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/fix-ruby.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Rewriting my Ruby code in Rust revealed a bug I never knew I had. As shown
above, I had to rework my Ruby code to check for a null last name inside the
block, similar to what I wrote in Rust. Even though it required more typing and
more work, Rust’s strict type system told me my code might crash at compile
time, while Ruby didn't tell me anything was wrong until runtime.&lt;/p&gt;
&lt;h2&gt;Rust vs. Ruby&lt;/h2&gt;
&lt;p&gt;In the end I was able to rewrite my Ruby code in Rust and get the same results.
&lt;a href=&quot;https://gist.github.com/patshaughnessy/db735e90d58376fdd550b35838aa5339&quot;&gt;This
gist&lt;/a&gt;
contains the Rust code I ended up with, if you’re interested in trying this
yourself.&lt;/p&gt;
&lt;p&gt;Writing the same algorithm in both languages and comparing, I noticed a few
obvious differences. First, the runtime execution performance was far superior
using Rust. I was able to load and process large sets of User records much,
much faster using Rust. But development performance was better using Ruby.  The
speed at which I was able to write working code was faster using Ruby.  It took
minutes to write the Ruby version, but hours to write the Rust version.  Of
course, I’m a Rust novice. An experienced Rust developer who knew what they
were doing could probably have written this in just a few minutes as well.
Second, Ruby is concise, while Rust is verbose. It took much more typing to
write Rust. But this extra thoroughness led me to find a bug in my Ruby code I
never knew I had.&lt;/p&gt;
&lt;p&gt;Which language is better? Neither. Ruby and Rust are different tools that are
best used in different circumstances.&lt;/p&gt;
&lt;p&gt;In the end what matters is that I learned something. One language isn’t better
than another - but now I’m a better developer because I took the time to learn
something new. By taking 5 hours instead of 5 minutes to accomplish a simple
task, I gained valuable insight and knowledge. I gave my mind the exercise it
was so hungry for. And thankfully no one noticed it took me 5 hours to run a
report that should have taken 5 minutes.&lt;/p&gt;
</content></entry><entry><title>How Rust Implements Tagged Unions</title><link href="http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions" rel="alternate"></link><id href="http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions" rel="alternate"></id><published>2018-03-15T00:00:00Z</published><updated>2018-03-15T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/covers.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(&lt;a href=&quot;https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131101633/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=J7H21QEX2A2NN3Y6EG00&quot;&gt;The C Programming Language&lt;/a&gt; and &lt;a href=&quot;https://nostarch.com</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/covers.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(&lt;a href=&quot;https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131101633/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=J7H21QEX2A2NN3Y6EG00&quot;&gt;The C Programming Language&lt;/a&gt; and &lt;a href=&quot;https://nostarch.com/Rust&quot;&gt;The Rust Programming Language&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;Rust &lt;a href=&quot;https://www.rust-lang.org/en-US/&quot;&gt;describes itself&lt;/a&gt; as:&lt;/p&gt;
&lt;blockquote&gt;
…a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
&lt;/blockquote&gt;
&lt;p&gt;Of course, this is in contrast to C, a different systems programming language
that encourages segfaults and makes no guarantees at all about thread safety.
Rust improves on C in many ways, most famously with its innovative ownnership
model for managing memory.&lt;/p&gt;
&lt;p&gt;Another less obvious improvement Rust makes to C has to do with the &lt;span
class=&quot;code&quot;&gt;union&lt;/span&gt; keyword. The Rust compiler implements &lt;em&gt;tagged
unions&lt;/em&gt;, which prevent you from crashing your program by initializing a union
with one variant and accessing it with another. &lt;del&gt;But the Rust doesn’t include
the &lt;span class=&quot;code&quot;&gt;union&lt;/span&gt; keyword at all&lt;/del&gt;; instead, Rust
uses &lt;span class=&quot;code&quot;&gt;enum&lt;/span&gt; to improve on both C enums and C unions at
the same time.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;p&gt;(Update: I heard &lt;a href=&quot;https://twitter.com/josh_triplett/status/974312496717742080&quot;&gt;on
Twitter&lt;/a&gt; and in
the comments that Rust does include untagged unions for use in FFI to
interoperate with C, or for unsafe code building custom unions.)&lt;/p&gt;
&lt;p&gt;Not sure what a tagged union is? Or why it’s an improvement over an old
fashioned C union? Today I’ll explain. First I’ll start with a quick review of
C unions, how they work and why they are dangerous. Then I’ll show you how Rust
enums improve on them.&lt;/p&gt;
&lt;h2&gt;C Unions&lt;/h2&gt;
&lt;p&gt;Unions are one of the most dangerous features of C. Here’s an example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/union1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here the union &lt;span class=&quot;code&quot;&gt;num_or_str&lt;/span&gt; saves either a number or
a character pointer but not both. (A union can contain any number of members;
for simplicity my example union has only two.) On the right I show how the C
compiler would allocate memory for an instance of &lt;span
class=&quot;code&quot;&gt;num_or_str&lt;/span&gt;. It allocates enough memory to hold the longest
value in the union, but not both values at the same time. The integer is a
short, meaning it occupies 16 bits or two bytes, and the string is a char
pointer which takes 64 bits or 8 bytes using a modern 64-bit CPU. The two
options for what might be stored in the union, &lt;span class=&quot;code&quot;&gt;num&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;str&lt;/span&gt; in this example, are known as &lt;em&gt;variants&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Why C Unions Are Dangerous&lt;/h2&gt;
&lt;p&gt;Unions are dangerous because you, the C programmer, need to remember which
variant you set in the union. If you save one type of value but then access the
other, your program will crash.&lt;/p&gt;
&lt;p&gt;For example this code works fine:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But if you forget &lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt; contains a number, and use
&lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt; as a string instead, your program will
crash:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Notice the C compiler didn’t help me here at all. It didn’t display any sort of
warning or error when I wrote &lt;span class=&quot;code&quot;&gt;a_number.str&lt;/span&gt;. It
silently allowed me to write dangerous code; in fact, union syntax encouraged
me to introduce a segmentation fault.&lt;/p&gt;
&lt;p&gt;Writing C code with unions is like driving very fast down a highway full of
potholes. You might be the best driver in the world, but eventually you’re
going to hit one of the holes and crash.&lt;/p&gt;
&lt;h2&gt;Tagged Unions&lt;/h2&gt;
&lt;p&gt;C programmers have been writing code with unions for years - for decades in
fact. How have they avoided this problem? There must be a safe way of writing C
code with unions.&lt;/p&gt;
&lt;p&gt;The most common and robust solution is to keep track of which union variant is
valid using an integer value saved right next to the union in memory. This
integer is known as a tag, and the combination of the tag and the union is a
&lt;em&gt;tagged union&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Here’s an example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/tagged_union.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;On the right side I’ve allocated some memory right before the union for the tag
using a struct. C structs, unlike unions, allocate enough memory to store all
of their members at once. Note: Using two bytes to save a small integer value
is unnecessary. C programs often use only one byte, or even represent the
integer value using a bit mask inside the union’s values. But the principle
remains the same.&lt;/p&gt;
&lt;p&gt;Now when I save an integer in an instance of the union I can also set the tag
to the value 1, for example, which I decide will mean that &lt;span
class=&quot;code&quot;&gt;a_number&lt;/span&gt; contains a number:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;And if I want to save a string instead, I set the tag to 2, for example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Later when I access the tagged union, I first check the tag before deciding
which variant I can access:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Of course, tagged unions are not foolproof. I invented the tag values 1 and 2
and wrote the code that checks for them. There’s nothing to prevent me from
forgetting to save the tag value, saving the wrong tag value or misinterpreting
the tag value when I later read it. And, if I ever add new variants to the
union, I have to add a new branch to every &lt;span class=&quot;code&quot;&gt;if&lt;/span&gt;
statement in my app that checks the tags, handling the new value. Needless to
say, the C compiler won’t help me find those &lt;span class=&quot;code&quot;&gt;if&lt;/span&gt;
statements or check whether I’ve covered all the possible tag values.&lt;/p&gt;
&lt;p&gt;I’m a forgetful and  easily distracted person. I need a programming language
that will keep me out of trouble. Even with tagged unions I’m sure I would
write dangerous, crashing C code before long.&lt;/p&gt;
&lt;h2&gt;Tagged Unions in Rust&lt;/h2&gt;
&lt;p&gt;Rust implements tagged unions using the &lt;span class=&quot;code&quot;&gt;enum&lt;/span&gt; keyword.
For example, to declare a Rust enum type equivalent to the C tagged union above
I write:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/rust-enum1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The questions for today are: Why are enums equivalent to tagged unions in C?
And: What should I draw on the right side? What would I see if I could find and
examine an enum in the memory space of a running Rust process?&lt;/p&gt;
&lt;h2&gt;Saving a Rust Enum&lt;/h2&gt;
&lt;p&gt;To find out, let’s create an instance of &lt;span class=&quot;code&quot;&gt;NumOrStr&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/rust-enum2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Notice that instead of 4, I’ve saved a more recognizable value, 1234. Now, if I
compile it with the &lt;span class=&quot;code&quot;&gt;-—emit asm&lt;/span&gt; flag:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/rust-emit-asm.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;…Rust generates a file called union.s which contains the assembly language
version of my program. If I open union.s and search for 1234, the integer value
I saved above, I see:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I’ve found it; here are the x86 assembly language instructions that initialize
&lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt;. These show me exactly how Rust represents
enums in memory, how Rust implements tagged unions.&lt;/p&gt;
&lt;p&gt;The only problem is… I have no idea what this means!&lt;/p&gt;
&lt;h2&gt;The movw x86 Instruction&lt;/h2&gt;
&lt;p&gt;What does &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt; mean? And what about &lt;span
class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;It turns out x86 assembly language isn’t that hard to follow, once you learn
the basic syntax. For a quick introduction, see my article from 2016: &lt;a href=&quot;http://patshaughnessy.net/2016/11/26/learning-to-read-x86-assembly-language&quot;&gt;Learning
to Read x86 Assembly
Language&lt;/a&gt;.
Intel, the company that built the microprocessor inside my Mac, defines the
&lt;span class=&quot;code&quot;&gt;mov&lt;/span&gt; instruction to mean “move.” (Note: the
instructions I show here that &lt;span class=&quot;code&quot;&gt;rustc —emit asm&lt;/span&gt;
generates aren’t written using Intel x86 syntax, but with GAS x86 syntax
instead.)&lt;/p&gt;
&lt;p&gt;Here’s a diagram showing what the first &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt;
instruction moves:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It turns out that &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt; stands for “move a word.” A
word is defined as 16 bits, or 2 bytes. There are a few different variations on
move, &lt;span class=&quot;code&quot;&gt;movb&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt;, &lt;span
class=&quot;code&quot;&gt;movl&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;movq&lt;/span&gt;, which move 1
byte, 2 bytes, 4 bytes or 8 bytes respectively.&lt;/p&gt;
&lt;p&gt;Next, the &lt;span class=&quot;code&quot;&gt;$&lt;/span&gt; notation indicates a literal value -  in
this case zero: &lt;span class=&quot;code&quot;&gt;$0&lt;/span&gt;. Now we can see the first
instruction above is moving 2 bytes containing the value zero. Similarly, the
second instruction is moving 2 bytes containing the value 1234:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm3.png&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;The rbp Register&lt;/h2&gt;
&lt;p&gt;But where are these &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt; instructions moving these
values to? To understand that we need to understand the odd &lt;span
class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt; syntax on the right side of the instructions. The
&lt;span class=&quot;code&quot;&gt;%&lt;/span&gt; sign indicates a register inside my Mac’s
microprocessor, in this case the “base pointer” register. So &amp;quot;bp&amp;quot; means &amp;quot;base
pointer.&amp;quot; And the “r” prefix in &amp;quot;rbp&amp;quot; means the move instruction is using all 8
bytes (64 bits) of this register’s value.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt; notation calculates a memory address
for the instruction using the contents of the &lt;span class=&quot;code&quot;&gt;%rbp&lt;/span&gt;
register - in this case the address of where to move the data to. The
expression &lt;span class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt; in English means: “Take the 64
bit memory address value from the base pointer register, and subtract 32 from
it.”&lt;/p&gt;
&lt;p&gt;Compiled Rust programs - all programs really - that run on the x86 platform
store values for local variables on the stack, using the base pointer register
in this fashion. The base pointer, as it’s name indicates, stores the base
address of my program's current stack frame. Each local variable in my code,
for example &lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt;, is saved somewhere on the
stack. If you’re not familiar with the concept of a stack, think of it as a
convenient place for quickly saving and retrieving values while your program is
running.&lt;/p&gt;
&lt;h2&gt;How Rust Saves an Integer Enum Variant&lt;/h2&gt;
&lt;p&gt;Taking a step back for a moment, here’s what we’ve learned so far. When I save
an enum value containing an integer, Rust saves &lt;em&gt;two&lt;/em&gt; values, 0 and 1234:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;What does the &lt;span class=&quot;code&quot;&gt;0&lt;/span&gt; mean? Rust records a zero to indicate
that &lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt; uses the &lt;span
class=&quot;code&quot;&gt;NumOrStr::Num&lt;/span&gt; variant. In other words, &lt;span
class=&quot;code&quot;&gt;a_number&lt;/span&gt; is a tagged union, and the zero value is the tag.
We know the tag occupies 2 bytes because of the &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt;
instruction above. The integer value itself, &lt;span class=&quot;code&quot;&gt;1234&lt;/span&gt;,
also takes 2 bytes because I declared it using &lt;span
class=&quot;code&quot;&gt;Num(i16)&lt;/span&gt;, and we saw Rust used a movw to save that also.&lt;/p&gt;
&lt;h2&gt;How Rust Saves an String Enum Variant&lt;/h2&gt;
&lt;p&gt;But what about the other variant, the string? When I save a string in &lt;span
class=&quot;code&quot;&gt;NumOrStr&lt;/span&gt;, what does Rust do? To find out, I’ll replace my
main function from above with this line of code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The I’ll compile it again using the &lt;span class=&quot;code&quot;&gt;--emit asm&lt;/span&gt;
option. Now I find this assembly language code in the union.s file:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Unfortunately this code snippet is much more complex: It first calls &lt;span
class=&quot;code&quot;&gt;String::from&lt;/span&gt; passing a string literal, and then saves the
string into the enum via a method called &lt;span
class=&quot;code&quot;&gt;drop_in_place&lt;/span&gt;. This is much harder to understand.&lt;/p&gt;
&lt;p&gt;Rather than trying to figure this out, I decided to debug my Rust sample
program using LLDB, and inspect the memory &lt;span class=&quot;code&quot;&gt;a_string&lt;/span&gt;
occupies. I found that Rust used 26 bytes to represent the string variant,
starting with a 16 bit word containing 1:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This is again the tag; in this case &lt;span class=&quot;code&quot;&gt;1&lt;/span&gt; means &lt;span
class=&quot;code&quot;&gt;a_string&lt;/span&gt; uses the &lt;span class=&quot;code&quot;&gt;NumOrStr::Str&lt;/span&gt;
variant. Following this I found a pointer to the string itself:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pointers on a 64-bit microprocessor occupy 8 bytes and contain the memory
address of something, in this case my string &amp;quot;This is a test.” After the
pointer I found two 64 bit values, each containing 15:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;These are two attributes of the string: its capacity and length. By inspecting
my process's memory I’ve started to learn a bit about how Rust manages memory
for strings.&lt;/p&gt;
&lt;p&gt;But what’s important for me today is the first word, the value 1. Again, we see
the same pattern. Rust saves an integer value, the tag, indicating which
variant this instance of the enum uses. Then Rust saves the enum variant’s
payload in the memory that follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save6.png&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Tagged Unions in Rust and C&lt;/h2&gt;
&lt;p&gt;Let’s review by declaring a tagged union in C and Rust:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/review1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;On the left using C, I have to include the tag explicitly in a surrounding
struct. Rust handles this for me automatically, saving the tag value inside the
enum alongside the enum’s value. The code looks very different, but as we saw above
the implementations are_ identical_.&lt;/p&gt;
&lt;p&gt;Using a tagged union looks somewhat similar in C and Rust:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/review2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But there are very important differences here! Using C, I need to remember to
check the tag and to use the proper variant inside the union. The Rust
compiler, on the other hand, checks the tag for me automatically and won’t
allow me to access the wrong variant. The code inside of &lt;span class=&quot;code&quot;&gt;if
let&lt;/span&gt; will never be executed unless the internal tag value matches the
&lt;span class=&quot;code&quot;&gt;NumOrStr::Num&lt;/span&gt; variant.&lt;/p&gt;
&lt;p&gt;Under the hood, the two languages implement tagged unions the same way. But
writing code in C and Rust is very different. C encourages me to write
dangerous, crashing code, while Rust prevents me from writing dangerous code in
the first place.&lt;/p&gt;
</content></entry><entry><title>Learning Rust: If Let vs. Match</title><link href="http://patshaughnessy.net/2018/1/18/learning-rust-if-let-vs--match" rel="alternate"></link><id href="http://patshaughnessy.net/2018/1/18/learning-rust-if-let-vs--match" rel="alternate"></id><published>2018-01-18T00:00:00Z</published><updated>2018-01-18T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: right; padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/1/18/dictionary.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Human languages have similar words with different&lt;br/&gt; shades of meaning. Some computer languages do too.&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:ĸra_in_a_dictionary_(ubt).JPG&quot;&gt;Wikimedia Commons</summary><content type="html">&lt;div style=&quot;float: right; padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/1/18/dictionary.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Human languages have similar words with different&lt;br/&gt; shades of meaning. Some computer languages do too.&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:ĸra_in_a_dictionary_(ubt).JPG&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;This year I’ve decided to try to learn &lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;. I’m
fascinated by its ownership model for memory management; I’m curious what the
claims about safety are all about; and, I love how it incorporates ideas from
the functional programming world. But I haven’t gotten to all of that yet - I’m
just getting started learning the basic syntax.&lt;/p&gt;
&lt;p&gt;Learning a computer language is just like learning a human language. You have
to try to read and write it everyday, even if just for a few minutes. You need
to get to know some native speakers. And there’s no way around it: You need to
learn the basic vocabulary of the language, word by word. To make things worse,
our human languages usually have several  words that mean the same thing. Which
one should I use? Sometime only a native speaker will really know.&lt;/p&gt;
&lt;p&gt;This week I was reading about &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;match&lt;/span&gt; in &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch06-03-if-let.html&quot;&gt;The Rust Programming
Book&lt;/a&gt;
(TRPL). I read that &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; is really syntactic sugar
for &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt;:&lt;/p&gt;
&lt;div style=&quot;padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
&lt;img width=&quot;500&quot; src=&quot;http://patshaughnessy.net/assets/2018/1/18/trpl-quote.png&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;This intrigued me. The phrase “syntactic sugar” implies the two code snippets
don’t only produce the same results, it means the compiler generates exactly
the same code in each case.&lt;/p&gt;
&lt;p&gt;Does the Rust compiler really generate exactly the same code for &lt;span
class=&quot;code&quot;&gt;if let&lt;/span&gt; as it does for &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt;? Read
on to find out. Today I’ll start with a quick review of the syntax and meaning
of &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt;. Then
I’ll take a look at how Rust compiles &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; and
&lt;span class=&quot;code&quot;&gt;match&lt;/span&gt;, at what code it produces.&lt;/p&gt;
&lt;h2&gt;If Let Compares a Pattern with a Value&lt;/h2&gt;
&lt;p&gt;The idea behind &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; is that it compares a pattern
with a value:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/1/18/pattern-value.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In this example &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; compares the pattern &lt;span
class=&quot;code&quot;&gt;Some(3)&lt;/span&gt; with the value &lt;span
class=&quot;code&quot;&gt;some_u8_value&lt;/span&gt;. If there’s a match, &lt;span class=&quot;code&quot;&gt;if
let&lt;/span&gt; executes the &lt;span class=&quot;code&quot;&gt;println!&lt;/span&gt; code inside the
block.&lt;/p&gt;
&lt;h2&gt;If Let Also Assigns Values&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; assigns a value at the same time, when the
pattern matches the value. This is the idea behind including the &lt;span class=&quot;code&quot;&gt;let&lt;/span&gt; keyword
after &lt;span class=&quot;code&quot;&gt;if&lt;/span&gt;. This is more apparent if I rewrite the example using a variable &lt;span class=&quot;code&quot;&gt;i&lt;/span&gt;
instead of 3. I'll also add a main function so I can execute the code:&lt;/p&gt;
&lt;pre&gt;
fn main() {
  let some_u8_value = Some(3u8);
  if let Some(i) = some_u8_value {
     println!(&quot;assigned {} to i&quot;, i);
  }
}
&lt;/pre&gt;
&lt;p&gt;When I saved this in a file called if-let.rs and ran it, I got:&lt;/p&gt;
&lt;pre&gt;
$ rustc if-let.rs
$ ./main
Assigned 3 to i
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; “unwrapped” the option structure, and assigned
the value 3 to the identifier &lt;span class=&quot;code&quot;&gt;i&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Match: If Let’s Big Brother&lt;/h2&gt;
&lt;p&gt;As TRPL explains, I could also have written this using the &lt;span
class=&quot;code&quot;&gt;match&lt;/span&gt; keyword, as follows:&lt;/p&gt;
&lt;pre&gt;
fn main() {
    let some_u8_value = Some(3u8);
    match some_u8_value {
        Some(i) =&gt; println!(&quot;Matched: {}&quot;, i),
        None =&gt; (),
    }
}
&lt;/pre&gt;
&lt;p&gt;To write this all I had to do was move things around a bit in my &lt;span
class=&quot;code&quot;&gt;if let&lt;/span&gt; code snippet from above:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2018/1/18/if-let-match.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Because there was no else clause for the &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt;
statement, I used &lt;span class=&quot;code&quot;&gt;None =&amp;gt; ()&lt;/span&gt; in match.&lt;/p&gt;
&lt;p&gt;Saving this code in match.rs and running it I got the same result:&lt;/p&gt;
&lt;pre&gt;
$ rustc match.rs
$ ./main
Matched: 3
&lt;/pre&gt;
&lt;h2&gt;Mid-Level IR (MIR)&lt;/h2&gt;
&lt;p&gt;I was curious though: If these two code snippets are entirely equivalent, then
the Rust compiler should generate &lt;em&gt;exactly the same executable program&lt;/em&gt; when I
compile them. In theory, therefore, I should be able to compare the two
executable binaries to test whether TRPL’s statement about syntactic sugar is
accurate. But comparing binary executables might not work. Likely there are
timestamps or other ephemeral values encoded in the executable that would break
the comparison. I decided to look for an easier way to test the compiler’s
output.&lt;/p&gt;
&lt;p&gt;Then I came across mid-level intermediate representation (MIR), described &lt;a href=&quot;https://blog.rust-lang.org/2016/04/19/MIR.html&quot;&gt;here
on the Rust blog&lt;/a&gt;. MIR is an
internal text language the rust compiler produces when you include the
&lt;span class=&quot;code&quot;&gt;—emit-mir&lt;/span&gt; flag, like this:&lt;/p&gt;
&lt;pre&gt;
$ rustc --emit mir if-let.rs
&lt;/pre&gt;
&lt;p&gt;With this option specified, rust generates a file called if-let.mir. Opening up
this file, I see:&lt;/p&gt;
&lt;pre&gt;
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -&gt; () {
    let mut _0: ();                      // return pointer
    scope 1 {
        let _1: std::option::Option&lt;u8&gt;; // &quot;some_u8_value&quot; in scope 1 at src/if-let.rs:16:9: 16:22

etc…
&lt;/pre&gt;
&lt;p&gt;“Knock yourself out;” now I’m really intrigued!&lt;/p&gt;
&lt;h2&gt;A First Look at MIR&lt;/h2&gt;
&lt;p&gt;I decided to compare the MIR text file the Rust compiler produced for the &lt;span class=&quot;code&quot;&gt;if
let&lt;/span&gt; snippet vs. the &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt; snippet. If Rust
considers &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; to be syntactic sugar for &lt;span
class=&quot;code&quot;&gt;match&lt;/span&gt;, then the MIR representation of the two snippets
should be the same.&lt;/p&gt;
&lt;p&gt;But when I started reading the MIR code, I found the call to the &lt;span
class=&quot;code&quot;&gt;println!&lt;/span&gt; macro generated a lot of verbose text:&lt;/p&gt;
&lt;pre&gt;
let mut _3: isize;
let mut _4: ();
let mut _5: std::fmt::Arguments;
let mut _6: &amp;[&amp;str];
let mut _7: &amp;[&amp;str; 2];
let mut _8: &amp;[&amp;str; 2];
let mut _9: &amp;[std::fmt::ArgumentV1];
let mut _10: &amp;[std::fmt::ArgumentV1; 1];
let mut _11: &amp;[std::fmt::ArgumentV1; 1];
let mut _12: [std::fmt::ArgumentV1; 1];
let mut _13: (&amp;u8,);
let mut _14: &amp;u8;
let mut _16: std::fmt::ArgumentV1;
let mut _17: &amp;u8;
let mut _18: fn(&amp;u8, &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::result::Result&lt;(), std::fmt::Error&gt;;
&lt;/pre&gt;
&lt;p&gt;All of this MIR pseudocode might confuse my comparison unnecessarily, so I
decided to simplify my &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; example by removing the
&lt;span class=&quot;code&quot;&gt;println!&lt;/span&gt; call entirely. I rewrote the &lt;span
class=&quot;code&quot;&gt;if let&lt;/span&gt; snippet like this (if-let.rs):&lt;/p&gt;
&lt;pre&gt;
fn main() {
    let some_u8_value = Some(3u8);
    if let Some(i) = some_u8_value {
        let _ = i;
    }
}
&lt;/pre&gt;
&lt;p&gt;And the &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt; snippet like this (match.rs):&lt;/p&gt;
&lt;pre&gt;
fn main() {
    let some_u8_value = Some(3u8);
    match some_u8_value {
        Some(i) =&gt; { let _ = i; }
        None =&gt; ()
    }
}
&lt;/pre&gt;
&lt;p&gt;I also noticed the MIR file contained many comments with line numbers:&lt;/p&gt;
&lt;pre&gt;
_2 = ((_1 as Some).0: u8);       // scope 3 at if-let.rs:3:17: 3:18
StorageLive(_5);                 // scope 3 at &lt;print macros&gt;:2:27: 2:58
StorageLive(_6);                 // scope 3 at &lt;println macros&gt;:3:18: 3:43
&lt;/pre&gt;
&lt;p&gt;I realized the line numbers would likely cause problems comparing one MIR file
to another, so I removed all of the comments using sed:&lt;/p&gt;
&lt;pre&gt;
$ rustc if-let.rs --emit mir
$ cat if-let.mir | sed -e 's/\/\/.*$//' &gt; if-let.mir.nocomments
&lt;/pre&gt;
&lt;p&gt;This generates a new text file called if-let.mir.nocomments, which contains the
same content as if-let.mir, but with no comments. And this command processes
the match.rs file in the same way:&lt;/p&gt;
&lt;pre&gt;
$ rustc match.rs --emit mir
$ cat match.mir | sed -e 's/\/\/.*$//' &gt; match.mir.nocomments
&lt;/pre&gt;
&lt;h2&gt;Comparing MIR Files&lt;/h2&gt;
&lt;p&gt;Now I ran a simple diff command on the simplified MIR text files. If the
compiler considers &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; to be exactly the same as
&lt;span class=&quot;code&quot;&gt;match&lt;/span&gt; then there should be no difference, then the
output of diff should be empty.&lt;/p&gt;
&lt;p&gt;But running diff I saw:&lt;/p&gt;
&lt;pre&gt;
$ diff if-let.mir.nocomments match.mir.nocomments
19c19
&lt;         switchInt(_3) -&gt; [1isize: bb2, otherwise: bb1];
---
&gt;         switchInt(_3) -&gt; [0isize: bb1, otherwise: bb2];
&lt;/pre&gt;
&lt;p&gt;My two MIR files are &lt;em&gt;almost&lt;/em&gt; identical; the MIR text Rust generates for &lt;span
class=&quot;code&quot;&gt;if let&lt;/span&gt; is exactly the same as the MIR text Rust generates
for &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt;, except for line 19. I’ve &lt;em&gt;almost&lt;/em&gt; proven
the hypothesis that &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; is syntactic sugar for
&lt;span class=&quot;code&quot;&gt;match&lt;/span&gt;, but not quite.&lt;/p&gt;
&lt;p&gt;Let’s take a close look at the MIR code around line 19 and try to understand
what it means. Here’s a portion of if-let.mir.nocomments, produced by the Rust
compiler from my &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; code above:&lt;/p&gt;
&lt;pre&gt;
bb0: {
    StorageLive(_1);
    _1 = std::option::Option&lt;u8&gt;::Some(const 3u8,);
    _3 = discriminant(_1);
    switchInt(_3) -&gt; [1isize: bb2, otherwise: bb1];
}

bb1: {
    _0 = ();
    goto -&gt; bb3;
}

bb2: {
    StorageLive(_2);
    _2 = ((_1 as Some).0: u8);
    _0 = ();
    goto -&gt; bb3;
}
&lt;/pre&gt;
&lt;p&gt;I don’t understand MIR syntax, but it’s not hard to guess what’s going on. Each
of these “bb” blocks of code &lt;span class=&quot;code&quot;&gt;{ … }&lt;/span&gt; probably
represents a logical piece of my program.&lt;/p&gt;
&lt;p&gt;The first block, &lt;span class=&quot;code&quot;&gt;bb0&lt;/span&gt;, seems to assign the value &lt;span class=&quot;code&quot;&gt;Some(3)&lt;/span&gt; to _1, and then calls
&lt;span class=&quot;code&quot;&gt;discriminant(_1)&lt;/span&gt; and saves the “discriminant,” whatever that is, in _3.
Finally, it tests whether the discriminant is 1. If the discriminant is 1 it
jumps to &lt;span class=&quot;code&quot;&gt;bb2&lt;/span&gt;, or otherwise to &lt;span
class=&quot;code&quot;&gt;bb1&lt;/span&gt;. So &lt;span class=&quot;code&quot;&gt;bb0&lt;/span&gt; likely represents the
&lt;span class=&quot;code&quot;&gt;if&lt;/span&gt; portion of my &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt;
snippet, testing a condition:&lt;/p&gt;
&lt;pre&gt;
if let Some(i) = some_u8_value
&lt;/pre&gt;
&lt;p&gt;The &lt;span class=&quot;code&quot;&gt;bb1&lt;/span&gt; block saves &lt;span class=&quot;code&quot;&gt;()&lt;/span&gt; in &lt;span
class=&quot;code&quot;&gt;_0&lt;/span&gt; and jumps to &lt;span class=&quot;code&quot;&gt;bb3&lt;/span&gt;. This likely represents the
missing/default else clause of my &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; statement.&lt;/p&gt;
&lt;p&gt;And the &lt;span class=&quot;code&quot;&gt;bb2&lt;/span&gt; block saves 3, the unwrapped value inside of &lt;span class=&quot;code&quot;&gt;Some(3)&lt;/span&gt;, in &lt;span class=&quot;code&quot;&gt;_2&lt;/span&gt; and
jumps to &lt;span class=&quot;code&quot;&gt;bb3&lt;/span&gt;. Probably &lt;span class=&quot;code&quot;&gt;_2&lt;/span&gt; is the variable &lt;span class=&quot;code&quot;&gt;i&lt;/span&gt;, and this block of MIR text
represents the &lt;span class=&quot;code&quot;&gt;let&lt;/span&gt; portion of my &lt;span
class=&quot;code&quot;&gt;if let&lt;/span&gt; snippet:&lt;/p&gt;
&lt;pre&gt;
let Some(i) = some_u8_value
let _ = i;
&lt;/pre&gt;
&lt;p&gt;Now let’s take a look at the &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt; version, the contents of
match.mir.nocomments. It’s entirely the same, except for the &lt;span class=&quot;code&quot;&gt;switchInt&lt;/span&gt; line:&lt;/p&gt;
&lt;pre&gt;
bb0: {
    StorageLive(_1);
    _1 = std::option::Option&lt;u8&gt;::Some(const 3u8,);
    _3 = discriminant(_1);
    &lt;b&gt;switchInt(_3) -&gt; [0isize: bb1, otherwise: bb2];&lt;/b&gt;
}
&lt;/pre&gt;
&lt;p&gt;Reading this carefully, I saw that actually it does mean the same thing: If the
discriminant is 0, Rust calls the &lt;span class=&quot;code&quot;&gt;bb1&lt;/span&gt; block, or
otherwise the &lt;span class=&quot;code&quot;&gt;bb2&lt;/span&gt; block.&lt;/p&gt;
&lt;p&gt;So, summarizing, the &lt;span class=&quot;code&quot;&gt;if let&lt;/span&gt; snippet ran this
pseudo-code:&lt;/p&gt;
&lt;blockquote&gt;
If the discriminant is 1, call bb1, else bb2.
&lt;/blockquote&gt;
&lt;p&gt;…and the &lt;span class=&quot;code&quot;&gt;match&lt;/span&gt; snippet ran this pseudo-code:&lt;/p&gt;
&lt;blockquote&gt;
If the discriminant is 0, call bb2, else bb1.
&lt;/blockquote&gt;
&lt;p&gt;So, in fact, the two versions use the same logic, assuming the value of
discriminant is either 0 or 1. If discriminant = 0, Rust assumes the comparison
was true and executes the match clause; if discriminant = 1, Rust executes the
else clause.&lt;/p&gt;
&lt;p&gt;Clearly the discriminant function is crucial - when I have time next, I’ll
explore what discriminant means, where it’s implemented and how it works. Or if
anyone from the Rust teams happens to read this, let us know.&lt;/p&gt;
</content></entry><entry><title>Looking Inside Postgres at a GiST Index</title><link href="http://patshaughnessy.net/2017/12/15/looking-inside-postgres-at-a-gist-index" rel="alternate"></link><id href="http://patshaughnessy.net/2017/12/15/looking-inside-postgres-at-a-gist-index" rel="alternate"></id><published>2017-12-15T00:00:00Z</published><updated>2017-12-15T00:00:00Z</updated><category>the Postgres LTREE Extension</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/tree5.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt; What do Postgres GiST indexes look like? How are&lt;br/&gt;
  they similar or different from standard Postgres indexes?&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;In the last few posts in this series
(&lt;a href=&quot;http://patshaughnessy.net/2017/12/11/trying-to-represe</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/tree5.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt; What do Postgres GiST indexes look like? How are&lt;br/&gt;
  they similar or different from standard Postgres indexes?&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;In the last few posts in this series
(&lt;a href=&quot;http://patshaughnessy.net/2017/12/11/trying-to-represent-a-tree-structure-using-postgres&quot;&gt;one&lt;/a&gt;,
&lt;a href=&quot;http://patshaughnessy.net/2017/12/12/installing-the-postgres-ltree-extension&quot;&gt;two&lt;/a&gt;,
&lt;a href=&quot;http://patshaughnessy.net/2017/12/13/saving-a-tree-in-postgres-using-ltree&quot;&gt;three&lt;/a&gt;
and
&lt;a href=&quot;http://patshaughnessy.net/2017/12/14/manipulating-trees-using-sql-and-the-postgres-ltree-extension&quot;&gt;four&lt;/a&gt;)
I showed you how to save hierarchical data in a flat database table using the
Postgres &lt;a href=&quot;https://www.postgresql.org/docs/current/static/ltree.html&quot;&gt;LTREE
extension&lt;/a&gt;. I
explained that you represent tree nodes using path strings and how to search
your tree data using special SQL operators LTREE provides.&lt;/p&gt;
&lt;p&gt;But the real value of LTREE isn’t the operators and functions it gives you -
internally these boil down to fairly simple string operations. Instead, what
makes LTREE useful is that it integrates these new operators with Postgres’s
indexing code, which allows you to search for and find matching tree paths
&lt;em&gt;quickly&lt;/em&gt;. To achieve this, LTREE takes advantage of the &lt;a href=&quot;http://gist.cs.berkeley.edu&quot;&gt;Generalized Search Tree
(GiST) project&lt;/a&gt;, an API that allows C developers
to extend Postgres’s indexing system.&lt;/p&gt;
&lt;p&gt;But what does the GiST API do? And what does it mean to extend Postgres’s
indexing system, exactly? Read on to find out!&lt;/p&gt;
&lt;h2&gt;Searching Without an Index&lt;/h2&gt;
&lt;p&gt;Here again is the tree table I used as an example in the earlier posts in this
series:&lt;/p&gt;
&lt;pre&gt;
create table tree(
    id serial primary key,
    letter char,
    path ltree
);
&lt;/pre&gt;
&lt;p&gt;Note the path column uses the custom &lt;span class=&quot;code&quot;&gt;ltree&lt;/span&gt; data type
the LTREE extension provides. If you missed the previous posts, &lt;span
class=&quot;code&quot;&gt;ltree&lt;/span&gt; columns represent hierarchical data by joining
strings together with periods, e.g.  “A.B.C.D” or “Europe.Estonia.Tallinn.”&lt;/p&gt;
&lt;p&gt;Earlier, I used a simple tree with only 7 nodes as an example. SQL operations
on a small table like this will always be fast. Today I’d like to imagine a
much larger tree to explore the benefits indexes can provide; suppose instead I
have a tree containing hundreds or thousands of records in the &lt;span
class=&quot;code&quot;&gt;path&lt;/span&gt; column:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/table.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now suppose I search for a single tree node using a select statement:&lt;/p&gt;
&lt;pre&gt;
select letter from tree where path = 'A.B.T.V'
&lt;/pre&gt;
&lt;p&gt;Without an index on this table, Postgres has to resort to a &lt;em&gt;sequence scan&lt;/em&gt;,
which is a technical way of saying that Postgres has to iterate over all of the
records in the table:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/table2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;For each and every record in the table, Postgres executes a comparison &lt;span
class=&quot;code&quot;&gt;p == q&lt;/span&gt; where &lt;span class=&quot;code&quot;&gt;p&lt;/span&gt; is the value of
the path column for each record in the table, and &lt;span class=&quot;code&quot;&gt;q&lt;/span&gt;
is the query, or the value I’m searching for, &lt;span class=&quot;code&quot;&gt;A.B.V.T&lt;/span&gt;
in this example. This loop can be very slow if there are many records. Postgres
has to check all of them, because they can appear in any order and there’s no
way to know how many matches there might be in the data ahead of time.&lt;/p&gt;
&lt;h2&gt;Searching With a B-Tree Index&lt;/h2&gt;
&lt;p&gt;Of course, there’s a simple solution to this problem; I just need to create an
index on the path column:&lt;/p&gt;
&lt;pre&gt;
create index tree_path_idx on tree (path);
&lt;/pre&gt;
&lt;p&gt;As you probably know, executing a search using an index is much faster. If you
see a performance problem with a SQL statement in your application, the first
thing you should check for is a missing index. But why? Why does creating an
index speed up searches, exactly? The reason is that an index is a sorted copy
of the target column’s data:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/index1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;By sorting the values ahead of time, Postgres can search through them much more
quickly. It uses a binary search algorithm:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/index2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Postgres starts by checking the value in the middle of the index. If the stored
value (&lt;span class=&quot;code&quot;&gt;p&lt;/span&gt;) is too large and is greater than the query
(&lt;span class=&quot;code&quot;&gt;q&lt;/span&gt;), if &lt;span class=&quot;code&quot;&gt;p &amp;gt; q&lt;/span&gt;, it moves up
and checks the value at the 25% position. If the value is too small, if &lt;span
class=&quot;code&quot;&gt;p &amp;lt; q&lt;/span&gt;, it moves down and checks the value at the 75%
position. Repeatedly dividing the index into smaller and smaller pieces,
Postgres only needs to search a few times before it finds the matching record
or records.&lt;/p&gt;
&lt;p&gt;However, for large tables with thousands or millions of rows Postgres can’t
save all of the sorted data values in a single memory segment. Instead,
Postgres indexes (and indexes inside of any relational database system) save
values in a &lt;em&gt;binary or balanced tree&lt;/em&gt; (B-Tree):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/index3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now my values are saved in a series of different memory segments arranged in a
tree structure. Dividing the index up into pieces allows Postgres to manage
memory properly while saving possibly millions of values in the index. Note
this isn’t the tree from my LTREE dataset; B-Trees are internal Postgres data
structures I don’t have access to. To learn more about the Computer Science
behind this read my 2014 article &lt;a href=&quot;http://patshaughnessy.net/2014/11/11/discovering-the-computer-science-behind-postgres-indexes&quot;&gt;Discovering the Computer Science Behind
Postgres
Indexes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now Postgres uses repeated binary searches, one for each memory segment in the
B-Tree, to find a value:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/index4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Each value in the parent or root segment is really a pointer to a child
segment. Postgres first searches the root segment using a binary search to find
the right pointer, and then jumps down to the child segment to find the actual
matching records using another binary search. The algorithm is recursive: The
B-Tree could contain many levels in which case the child segments would contain
pointers to grandchild segments, etc.&lt;/p&gt;
&lt;h2&gt;What’s the Problem with Standard Postgres Indexes?&lt;/h2&gt;
&lt;p&gt;But there’s a serious problem here I’ve overlooked so far. Postgres’s index
search code only supports certain operators. Above I was searching using this
select statement:&lt;/p&gt;
&lt;pre&gt;
select letter from tree where path = 'A.B.T.V'
&lt;/pre&gt;
&lt;p&gt;I was looking for records that were equal to my query: &lt;span class=&quot;code&quot;&gt;p ==
q&lt;/span&gt;. Using a B-Tree index I could also have searched for records greater
than or less than my query: &lt;span class=&quot;code&quot;&gt;p &amp;lt; q&lt;/span&gt; or &lt;span
class=&quot;code&quot;&gt;p &amp;gt; q&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;But what if I want to use the custom LTREE &lt;span class=&quot;code&quot;&gt;&amp;lt;@&lt;/span&gt;
(ancestor) operator? What if I want to execute this select statement?&lt;/p&gt;
&lt;pre&gt;
select letter from tree where path &lt;@ 'A.B.V'
&lt;/pre&gt;
&lt;p&gt;As we saw in the previous posts in this series, this search will return all of
the LTREE records that appear somewhere on the branch under &lt;span
class=&quot;code&quot;&gt;A.B.V&lt;/span&gt;, that are descendants of the &lt;span
class=&quot;code&quot;&gt;A.B.V&lt;/span&gt; tree node.&lt;/p&gt;
&lt;p&gt;A standard Postgres index doesn’t work here. To execute this search efficiently
using an index, Postgres needs to execute this comparison as it walks the
B-Tree: &lt;span class=&quot;code&quot;&gt;p &amp;lt;@ q&lt;/span&gt;. But the standard Postgres index
search code doesn’t support &lt;span class=&quot;code&quot;&gt;p &amp;lt;@ q&lt;/span&gt;. Instead, if I
execute this search Postgres resorts to a slow sequence scan again, even if I
create an index on the &lt;span class=&quot;code&quot;&gt;ltree&lt;/span&gt; column.&lt;/p&gt;
&lt;p&gt;To search tree data efficiently, we need a Postgres index that will perform
&lt;span class=&quot;code&quot;&gt;p &amp;lt;@ q&lt;/span&gt; comparisons equally well as &lt;span
class=&quot;code&quot;&gt;p == q&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;p &amp;lt; q&lt;/span&gt; comparisons. We
need a GiST index!&lt;/p&gt;
&lt;h2&gt;The Generalized Search Tree (GiST) project&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 0px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/berkeley.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;The Generalized Search Tree (GiST) project, like&lt;br/&gt;
Postgres itself, started at UC Berkeley.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Almost 20 years ago, an open source project at UC Berkeley solved this precise
problem. The &lt;a href=&quot;http://gist.cs.berkeley.edu&quot;&gt;Generalized Search Tree (GiST)
project&lt;/a&gt; added an API to Postgres allowing C
developers to extend the set of data types that can be used in a Postgres
index.&lt;/p&gt;
&lt;p&gt;Quoting from the project’s web page:&lt;/p&gt;
&lt;blockquote&gt;
In the beginning there was the B-tree. All database search trees since the
B-tree have been variations on its theme. Recognizing this, we have developed a
new kind of index called a Generalized Search Tree (GiST), which provides the
functionality of all these trees in a single package. The GiST is an extensible
data structure, which allows users to develop indices over any kind of data,
supporting any lookup over that data.
&lt;/blockquote&gt;
&lt;p&gt;GiST achieves this by adding an API to Postgres’s index system anyone can implement for their specific data type. GiST implements the general indexing and searching code, but calls out to custom code at four key moments in the indexing process. Quoting from the project’s web page again, here’s a quick explanation of the 4 methods in the GiST API:&lt;/p&gt;
&lt;div style=&quot;padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist.png&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;GiST indexes use a tree structure similar to the B-Tree we saw above. But
Postgres doesn’t create the GiST index tree structure by itself; Postgres works
with implementations of the GiST &lt;span class=&quot;code&quot;&gt;Union&lt;/span&gt;, &lt;span
class=&quot;code&quot;&gt;Penalty&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;PickSplit&lt;/span&gt; API
functions described above. And when you execute a SQL statement that searches
for a value in a GiST index, Postgres uses the &lt;span
class=&quot;code&quot;&gt;Consistent&lt;/span&gt; function to find the target values.&lt;/p&gt;
&lt;p&gt;The key here is the implementor of the GiST API can decide what type of data to
index and how to arrange those data values in the GiST tree. Postgres doesn’t
care what the data values are or how the tree looks. Postgres simply calls
&lt;span class=&quot;code&quot;&gt;Consistent&lt;/span&gt; any time it needs to search for a value
and lets the GiST API implementor find the value.&lt;/p&gt;
&lt;p&gt;An example would help understand this, and we have an example GiST API
implementation: The LTREE extension!&lt;/p&gt;
&lt;h2&gt;Implementing the GiST API for Tree Paths&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/moscow-state.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;The LTREE Postgres extension was developed at Moscow State&lt;br/&gt;
University by Oleg Bartunov and Teodor Sigaev.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Starting in around 2001, two students at Moscow State University found the API
from the GiST project and decided to use it to build indexing support for tree
data. Oleg Bartunov and Teodor Sigaev, in effect, wrote a “Tree Paths
Consistent” function, a “Tree Path Union” function, etc. The C code that
implements this API is the LTREE extension. You can find these functions,
&lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;ltree_union&lt;/span&gt;, among other functions, in a file called
ltree_gist.c, located in the contrib/ltree directory in the Postgres source
code. They also implemented the &lt;span class=&quot;code&quot;&gt;Penalty&lt;/span&gt;, &lt;span
class=&quot;code&quot;&gt;PickSplit&lt;/span&gt; and various other functions related to the GiST
algorithm.&lt;/p&gt;
&lt;p&gt;I can use these custom functions on my own data simply by creating a GiST
index. Returning to my LTREE example, I’ll drop my B-Tree index and create a
GiST index instead:&lt;/p&gt;
&lt;pre&gt;
drop index tree_path_idx;
create index tree_path_idx on tree using gist (path);
&lt;/pre&gt;
&lt;p&gt;Notice the &lt;span class=&quot;code&quot;&gt;using gist&lt;/span&gt; keywords in the &lt;span
class=&quot;code&quot;&gt;create index&lt;/span&gt; command. That’s all it takes; Postgres
automatically finds, loads and uses the &lt;span class=&quot;code&quot;&gt;ltree_union&lt;/span&gt;,
&lt;span class=&quot;code&quot;&gt;ltree_picksplit&lt;/span&gt; etc., functions whenever I insert a
new value into the table. (It will also insert all existing records into the
index immediately.) Of course, earlier I &lt;a href=&quot;http://patshaughnessy.net/2017/12/12/installing-the-postgres-ltree-extension&quot;&gt;installed the LTREE
extension&lt;/a&gt;
also.&lt;/p&gt;
&lt;p&gt;Let’s see how this works - suppose I add a few random tree records to my empty
tree table after creating the index:&lt;/p&gt;
&lt;pre&gt;
insert into tree (letter, path) values ('A', 'A.B.G.A');
insert into tree (letter, path) values ('E', 'A.B.T.E');
insert into tree (letter, path) values ('M', 'A.B.R.M');
insert into tree (letter, path) values ('F', 'A.B.E.F');
insert into tree (letter, path) values ('P', 'A.B.R.P');
&lt;/pre&gt;
&lt;p&gt;To get things started, Postgres will allocate a new memory segment for the GiST
index and insert my five records:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If I search now using the ancestor operator:&lt;/p&gt;
&lt;pre&gt;
select count(*) from tree where path &lt;@ 'A.B.T'
&lt;/pre&gt;
&lt;p&gt;…Postgres will simply iterate over the records in the same order I inserted
then, and call the &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; function for each
one. Here again is what the GiST API calls for the Consistent function to do:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/consistent.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In this case Postgres will compare &lt;span class=&quot;code&quot;&gt;p &amp;lt;@ A.B.T&lt;/span&gt; for
each of these five records:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Because the values of &lt;span class=&quot;code&quot;&gt;p&lt;/span&gt;, the tree page keys, are
simple path strings, &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; directly
compares them with &lt;/span&gt;A.B.T&lt;/span&gt; and determines immediately whether each
value is a descendent tree node of &lt;span class=&quot;code&quot;&gt;A.B.T&lt;/span&gt; or not.
Right now the GiST index hasn’t provided much value; Postgres has to iterate
over all the values, just like a sequence scan.&lt;/p&gt;
&lt;p&gt;Now suppose I start to add more and more records to my table. Postgres can fit
up to 136 LTREE records into the root GiST memory segment, and index scans
function the same way as a sequence scan by checking all the values.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But if I insert one more record, the 137th record doesn’t fit. At this point
Postgres has to do something different:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now Postgres “splits” the memory segment to make room for more values. It
creates two new child memory segments and pointers to them from the parent or
root segment.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;What does Postgres do next? What does it place into each child segment?
Postgres leaves this decision to the GiST API, to the LTREE extension, by
calling the the &lt;span class=&quot;code&quot;&gt;ltree_picksplit&lt;/span&gt; function. Here again
is the API spec for &lt;span class=&quot;code&quot;&gt;PickSplit&lt;/span&gt;:&lt;/p&gt;
&lt;div style=&quot;padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/pick-split.png&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;span class=&quot;code&quot;&gt;ltree_picksplit&lt;/span&gt; function - the LTREE
implementation of the GiST API - sorts the tree paths alphabetically and copies
each half into one of the two new child segments. Note that GiST indexes don’t
normally sort their contents; however, GiST indexes created specifically by the
LTREE extension do because of the way &lt;span class=&quot;code&quot;&gt;ltree_picksplit&lt;/span&gt;
works. We’ll see why it sorts the data in a moment.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now Postgres has to decide what to leave in the root segment. To do this, it
calls the Union GiST API:&lt;/p&gt;
&lt;div style=&quot;padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/union.png&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;In this example, each of the child segments is a set S. And the &lt;span
class=&quot;code&quot;&gt;ltree_union&lt;/span&gt; function has to return a “union” value for each
child segment that describes somehow what values are present in that segment:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Oleg and Teodor decided this union value should be a pair of left/right values
indicating the minimum and maximum tree branches inside of which all of the
values fit alphabetically. This is why the &lt;span
class=&quot;code&quot;&gt;ltree_picksplit&lt;/span&gt; function sorted the values. For example,
because the first child segment contains the sorted values from &lt;span
class=&quot;code&quot;&gt;A.B.C.B&lt;/span&gt; through &lt;span class=&quot;code&quot;&gt;A.B.M.Z&lt;/span&gt;, the
left/right union becomes &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;A.B.M&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Note &lt;span class=&quot;code&quot;&gt;A.B.M&lt;/span&gt; is sufficient here to form a union value
excluding &lt;span class=&quot;code&quot;&gt;A.B.N.X&lt;/span&gt; and all the following values; LTREE
doesn’t need to save &lt;span class=&quot;code&quot;&gt;A.B.M.Z&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Similarly, the left/right union for the second child segment becomes &lt;span
class=&quot;code&quot;&gt;A.B.N/A.B.X&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This is what a GiST index looks like. Or, what an LTREE GiST index looks like,
specifically. The power of the GiST API is that anyone can use it to create a
Postgres index for any type of data. Postgres will always use the same pattern:
The parent index page contains a set of union values, each of which somehow
describe the contents of each child index page.&lt;/p&gt;
&lt;p&gt;For LTREE GiST indexes, Postgres saves left/right value pairs to describe the
union of values that appear in each child index segment. For other types of
GiST indexes, the union values could be anything. For example, a GiST index
could store geographical information like latitude/longitude coordinates, or
colors, or any sort of data at all. What’s important is that each union value
describe the set of possible values that can appear under a certain branch of
the index. And like B-Trees, this union value/child page pattern is recursive:
A GiST index could hold millions of values in a tree with many pages saved in a
large multi-level tree.&lt;/p&gt;
&lt;h2&gt;Searching a GiST Index&lt;/h2&gt;
&lt;p&gt;After creating this GiST index tree, searching for a value is straightforward.
Postgres uses the &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; function. As an
example, let’s repeat the same SQL query from above:&lt;/p&gt;
&lt;pre&gt;
select count(*) from tree where path &lt;@ 'A.B.T'
&lt;/pre&gt;
&lt;p&gt;To execute this using the GiST index, Postgres iterates over the union values
in the root memory segment and calls the &lt;span
class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; function for each one:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/consistent.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now Postgres passes each union value to &lt;span
class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; to calculate the &lt;span class=&quot;code&quot;&gt;p &amp;lt;@
q&lt;/span&gt; formula. The code inside of &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt;
then returns &amp;quot;MAYBE&amp;quot; if &lt;span class=&quot;code&quot;&gt;q &amp;gt;
left&lt;/span&gt;, and &lt;span class=&quot;code&quot;&gt;q &amp;lt; right&lt;/span&gt;. Otherwise it returns
&amp;quot;NO.&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist10.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In this example you can see &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; finds
that the query &lt;span class=&quot;code&quot;&gt;A.B.T&lt;/span&gt;, or &lt;span class=&quot;code&quot;&gt;q&lt;/span&gt;,
&lt;em&gt;maybe&lt;/em&gt; is located inside the second child memory segment, but not the first one.&lt;/p&gt;
&lt;p&gt;For the first child union structure, &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt;
finds &lt;span class=&quot;code&quot;&gt;q &amp;gt; A&lt;/span&gt; true but &lt;span class=&quot;code&quot;&gt;q &amp;lt;
A.B.M&lt;/span&gt; false. Therefore &lt;span
class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; knows there can be no matches in the top
child segment, so it skips down to the second union structure.&lt;/p&gt;
&lt;p&gt;For the second child union structure, &lt;span class=&quot;code&quot;&gt;ltree_consistent&lt;/span&gt; finds both &lt;span class=&quot;code&quot;&gt;q &amp;gt; A.B.N&lt;/span&gt;
true and &lt;span class=&quot;code&quot;&gt;q &amp;lt; A.B.X&lt;/span&gt; true. Therefore it returns &lt;span
class=&quot;code&quot;&gt;MAYBE&lt;/span&gt;, meaning the search continues in the lower child
segment:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/gist11.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Note Postgres never had to search the first child segment: The tree structure
limits the comparisons necessary to just the values that might match &lt;span
class=&quot;code&quot;&gt;p &amp;lt;@ A.B.T&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Imagine my table contained a million rows: Searches using the GiST index will
still be fast because the GiST tree limits the scope of the search. Instead of
executing &lt;span class=&quot;code&quot;&gt;p &amp;lt;@ q&lt;/span&gt; on every one of the million rows,
Postgres only needs to run &lt;span class=&quot;code&quot;&gt;p &amp;lt;@ q&lt;/span&gt; a handful of times,
on a few union records and on the child segments of the tree that contain
values that might match.&lt;/p&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/sternberg.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;The Sternberg Astronomical Institute
at Moscow State University&lt;/i&gt;
&lt;/div&gt;
&lt;h2&gt;Send Them a Postcard&lt;/h2&gt;
&lt;p&gt;Oleg Bartunov and Teodor Sigaev, the authors of the LTREE extension, explain
its usage and the algorithms I detailed above here on their &lt;a href=&quot;http://www.sai.msu.su/%7Emegera/postgres/gist/ltree/&quot;&gt;web
page&lt;/a&gt;. They included more
examples of SQL searches on tree data, including some which use the &lt;span
class=&quot;code&quot;&gt;LTREE[]&lt;/span&gt; data type I didn’t have time to cover in these blog
posts.&lt;/p&gt;
&lt;p&gt;But most importantly, they included this note at the bottom:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/15/postcard.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Do you save tree data in Postgres? Does your app take advantage of the LTREE
extension? If so, you should send Oleg and Teodor a postcard! I just did.&lt;/p&gt;
</content></entry><entry><title>Manipulating Trees Using SQL and the Postgres LTREE Extension</title><link href="http://patshaughnessy.net/2017/12/14/manipulating-trees-using-sql-and-the-postgres-ltree-extension" rel="alternate"></link><id href="http://patshaughnessy.net/2017/12/14/manipulating-trees-using-sql-and-the-postgres-ltree-extension" rel="alternate"></id><published>2017-12-14T00:00:00Z</published><updated>2017-12-14T00:00:00Z</updated><category>the Postgres LTREE Extension</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: right; padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/14/tree4.jpg&quot;&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://patshaughnessy.net/2017/12/13/saving-a-tree-in-postgres-using-ltree&quot;&gt;Yesterday&lt;/a&gt;,
I used the &lt;a href=&quot;https://www.postgresql.org/docs/current/static/ltree.html&quot;&gt;LTREE&lt;/a&gt;
extension to save a tree data structure </summary><content type="html">&lt;div style=&quot;float: right; padding: 8px 0px 40px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/14/tree4.jpg&quot;&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://patshaughnessy.net/2017/12/13/saving-a-tree-in-postgres-using-ltree&quot;&gt;Yesterday&lt;/a&gt;,
I used the &lt;a href=&quot;https://www.postgresql.org/docs/current/static/ltree.html&quot;&gt;LTREE&lt;/a&gt;
extension to save a tree data structure in a Postgres table. After saving the
tree, I used the &lt;span class=&quot;code&quot;&gt;@&amp;gt;&lt;/span&gt; or ancestor operator to count the
number of descendant nodes on a given branch.&lt;/p&gt;
&lt;p&gt;But that’s not all LTREE can do. Today I’ll show you how to delete, move and
copy branches from one place to another in your tree, using &lt;span
class=&quot;code&quot;&gt;@&amp;gt;&lt;/span&gt; in combination with other LTREE functions. After that,
in &lt;a href=&quot;http://patshaughnessy.net/2017/12/15/looking-inside-postgres-at-a-gist-index&quot;&gt;my last post in this
series&lt;/a&gt;,
I’ll look at how LTREE works under the hood, at the Computer Science that makes
all of this possible.&lt;/p&gt;
&lt;h2&gt;My Example Tree Again&lt;/h2&gt;
&lt;p&gt;Here’s the tree I’ve been working with during the last few blog posts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/11/example-tree.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://patshaughnessy.net/2017/12/13/saving-a-tree-in-postgres-using-ltree&quot;&gt;In my last
post&lt;/a&gt;,
I saved this tree in my database using a series of insert statements:&lt;/p&gt;
&lt;pre&gt;
insert into tree (letter, path) values ('A', 'A');
insert into tree (letter, path) values ('B', 'A.B');
insert into tree (letter, path) values ('C', 'A.C');
insert into tree (letter, path) values ('D', 'A.C.D');
insert into tree (letter, path) values ('E', 'A.C.E');
insert into tree (letter, path) values ('F', 'A.C.F');
insert into tree (letter, path) values ('G', 'A.B.G');
&lt;/pre&gt;
&lt;p&gt;And we saw how easy it is to count the number of tree nodes in a given branch
using the &lt;span class=&quot;code&quot;&gt;@&amp;gt;&lt;/span&gt; operator:&lt;/p&gt;
&lt;pre&gt;
select count(*) from tree where 'A.C' @&gt; path;
&lt;/pre&gt;
&lt;h2&gt;Cutting Off a Branch&lt;/h2&gt;
&lt;p&gt;But suppose I wanted to remove these nodes from the tree entirely; that is,
suppose I wanted to “cut off this branch” of the tree, so to speak:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/14/cut-branch.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;How can I do this? Simple! I just use a SQL delete statement:&lt;/p&gt;
&lt;pre&gt;
delete from tree where 'A.C' @&gt; path;
&lt;/pre&gt;
&lt;p&gt;As you can see, I can use &lt;span class=&quot;code&quot;&gt;@&amp;gt;&lt;/span&gt; equally well in delete
statements as in select statements.&lt;/p&gt;
&lt;h2&gt;Replanting a Branch as a New Tree&lt;/h2&gt;
&lt;p&gt;Now suppose I want to keep this branch, and save it as a separate tree in my
table. That is, I want two trees: the original &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt; tree
and a new tree consisting of the &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt; branch “replanted”
as a new root:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/14/replanting.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Thinking about this for a moment, moving some nodes from one location to
another in my tree means I’ll need to update their path values somehow in my
table. That is, I’ll need to use an update statement and not a select or delete
statement.  But how? Writing an update statement is easy enough, but how do I
know what the new path of each tree node will be? Let’s take &lt;span
class=&quot;code&quot;&gt;C&lt;/span&gt; as an example. Because &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt; will
become the root node of my new tree, I want to change its path from &lt;span
class=&quot;code&quot;&gt;A.C&lt;/span&gt; to just &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
update tree set path = 'C' where path = 'A.C';
&lt;/pre&gt;
&lt;p&gt;And I will want to update &lt;span class=&quot;code&quot;&gt;D&lt;/span&gt;, one of &lt;span
class=&quot;code&quot;&gt;C&lt;/span&gt;’s children, in a similar way:&lt;/p&gt;
&lt;pre&gt;
update tree set path = 'C.D' where path = 'A.C.D';
&lt;/pre&gt;
&lt;p&gt;I could write a separate update statement for each node, just 4 SQL statements
for my example. But imagine I had 100s or 1000s of nodes in my tree. Updating
the records one SQL statement at a time would require repeated network
connections from my application to Postgres, slowing down the overall operation
tremendously.&lt;/p&gt;
&lt;p&gt;Instead, I need to update the path of &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt; and each of
its descendants all in a single operation. But how can I do this? Two LTREE
functions, &lt;span class=&quot;code&quot;&gt;NLEVEL()&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;SUBPATH()&lt;/span&gt;, can help.&lt;/p&gt;
&lt;h2&gt;The NLEVEL Function&lt;/h2&gt;
&lt;p&gt;First, &lt;span class=&quot;code&quot;&gt;NLEVEL&lt;/span&gt;. As you might guess, this returns the
number of levels in a given path string:&lt;/p&gt;
&lt;pre&gt;
select letter, path, nlevel(path) from tree;

letter | path  | nlevel 
-------+-------+--------
A      | A     |      1
B      | A.B   |      2
C      | A.C   |      2
D      | A.C.D |      3
E      | A.C.E |      3
F      | A.C.F |      3
G      | A.B.G |      3
(7 rows)
&lt;/pre&gt;
&lt;p&gt;Looking at this, it’s easy to understand what the function returns: For a root
node like &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;NLEVEL&lt;/span&gt; returns 1.
For &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt;’s child nodes, &lt;span class=&quot;code&quot;&gt;A.B&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;A.C&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;NLEVEL&lt;/span&gt; returns 2,
and for the grandchild nodes it returns 3. It simply counts the number of
levels in each path string; internally, it parses the path string for period
characters.&lt;/p&gt;
&lt;p&gt;Before we continue, consider one subtle but important point. Notice that I was
able to calculate &lt;span class=&quot;code&quot;&gt;NLEVEL&lt;/span&gt; on &lt;em&gt;all of the records&lt;/em&gt; in
the tree table with a single SQL statement! Postgres applied the function to
all of the matching paths for me. The power of LTREE’s functions is that they
seamlessly integrate with SQL, harnessing and extending the power of Postgres.&lt;/p&gt;
&lt;h2&gt;The SUBPATH Function&lt;/h2&gt;
&lt;p&gt;LTREE provides another new SQL function that will also help us write a general
tree path formula: &lt;span class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt;. As you might guess, this
returns a selected substring from a given path. Let’s try running it on my
example tree:&lt;/p&gt;
&lt;pre&gt;
select letter, subpath(path, 1) from tree;
ERROR:  invalid positions
STATEMENT:  select letter, subpath(path, 1) from tree;
&lt;/pre&gt;
&lt;p&gt;Oops - I’ve done something wrong here. Calling &lt;span class=&quot;code&quot;&gt;SUBPATH(path,
1)&lt;/span&gt; returns the portion of the path starting with offset 1. Not a
character offset, but a &lt;em&gt;path offset&lt;/em&gt;. So &lt;span class=&quot;code&quot;&gt;SUBPATH(path,
1)&lt;/span&gt; drops the first level of the path, &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt; in my
tree, and returns the remaining portion of each path starting from the second
path element. Internally, LTREE parses the periods for me, drops the requested
number of path levels and removes the extra leading period.&lt;/p&gt;
&lt;p&gt;In the statement above, the error was caused by the root node in the tree:
&lt;span class=&quot;code&quot;&gt;A&lt;/span&gt;.  This path has only one level, and so LTREE
returns an error in this case.&lt;/p&gt;
&lt;p&gt;Let’s try using &lt;span class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt; only on the &lt;span
class=&quot;code&quot;&gt;C&lt;/span&gt; branch, the branch we want to move:&lt;/p&gt;
&lt;pre&gt;
select letter, subpath(path, 1) from tree where path &lt;@ 'A.C';
letter | subpath 
-------+---------
C      | C
D      | C.D
E      | C.E
F      | C.F
(4 rows)
&lt;/pre&gt;
&lt;p&gt;Now I get only four records in the result, one for &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt;
and one for each node that appears under &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt;. And you
can see the &lt;span class=&quot;code&quot;&gt;subpath&lt;/span&gt; column contains the portion of
the path that appears after &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt;, for each of these 4
records.&lt;/p&gt;
&lt;p&gt;And again, notice that I was able to execute the &lt;span
class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt; function on all 4 tree records I wanted to, in a
single operation. This time, the &lt;span class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt; function
worked in concert with the &lt;span class=&quot;code&quot;&gt;&amp;lt;@&lt;/span&gt; operator. LTREE has
made the SQL language I already know how to use even more powerful.&lt;/p&gt;
&lt;h2&gt;Moving Tree Nodes Using One UPDATE Statement&lt;/h2&gt;
&lt;p&gt;Now let’s return to the question of moving a branch into a new tree. As this
diagram shows, I want to delete &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt; and its children
from the &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt; tree, and move them to a new location:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/14/replanting.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Earlier I considered moving the nodes using a single update statement for each:&lt;/p&gt;
&lt;pre&gt;
update tree set path = 'C' where path = 'A.C';
update tree set path = 'C.D' where path = 'A.C.D';
update tree set path = 'C.E' where path = 'A.C.E';
update tree set path = 'C.F' where path = 'A.C.F';
&lt;/pre&gt;
&lt;p&gt;Now that I know about &lt;span class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt;, it’s easy to write a
single SQL update statement that will move all 4 nodes in the &lt;span
class=&quot;code&quot;&gt;C&lt;/span&gt; branch in one operation:&lt;/p&gt;
&lt;pre&gt;
update tree set path = subpath(path, 1) where path &lt;@ 'A.C';
&lt;/pre&gt;
&lt;p&gt;I use &lt;span class=&quot;code&quot;&gt;where path &amp;lt;@ 'A.C'&lt;/span&gt; to scope the update to the
&lt;span class=&quot;code&quot;&gt;C&lt;/span&gt; branch, and I use &lt;span class=&quot;code&quot;&gt;subpath(path,
1)&lt;/span&gt; to remove the &lt;span class=&quot;code&quot;&gt;A&lt;/span&gt; root element from the path
of &lt;span class=&quot;code&quot;&gt;C&lt;/span&gt; and each of its descendants.&lt;/p&gt;
&lt;p&gt;I can generalize this a bit more using the &lt;span class=&quot;code&quot;&gt;NLEVEL&lt;/span&gt;
function also:&lt;/p&gt;
&lt;pre&gt;
update tree set path = subpath(path, nlevel('A.C')-1) where path &lt;@ 'A.C';
&lt;/pre&gt;
&lt;p&gt;This follows because &lt;span class=&quot;code&quot;&gt;nlevel('A.C') = 2&lt;/span&gt;, and
therefore, &lt;span class=&quot;code&quot;&gt;nlevel('A.C')-1&lt;/span&gt; returns the same formula
we had above. Replacing &lt;span class=&quot;code&quot;&gt;A.C&lt;/span&gt; with “BRANCH_PATH” I
arrive at a general formula for “replanting” a branch as a new tree using a
single SQL statement:&lt;/p&gt;
&lt;pre&gt;
update tree set path = subpath(path, nlevel(BRANCH_PATH)-1) where path &lt;@ BRANCH_PATH
&lt;/pre&gt;
&lt;p&gt;…assuming &lt;span class=&quot;code&quot;&gt;nlevel(BRANCH_PATH) &amp;gt; 1&lt;/span&gt;, that is assuming
the branch we want to replant isn’t already a root.&lt;/p&gt;
&lt;h2&gt;The || Concatenation Operator&lt;/h2&gt;
&lt;p&gt;This seems somewhat useful, but what if I want to move a branch from one
location in my tree to some other location, not necessary to the root? This is
a more general problem. For example, suppose I want to move the &lt;span
class=&quot;code&quot;&gt;C&lt;/span&gt; branch under &lt;span class=&quot;code&quot;&gt;G&lt;/span&gt;, like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2017/12/14/moving.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;To write a formula for this transformation using SQL, we need to use one more
important LTREE operator: the &lt;span class=&quot;code&quot;&gt;||&lt;/span&gt; or concatenation
operator. Let’s try it out with an example first:&lt;/p&gt;
&lt;pre&gt;
select 'A.B.G' || path as concatenated from tree;
concatenated 
--------------
A.B.G.A
A.B.G.A.B
A.B.G.A.C
A.B.G.A.C.D
A.B.G.A.C.E
A.B.G.A.C.F
A.B.G.A.B.G
(7 rows)
&lt;/pre&gt;
&lt;p&gt;You can see LTREE has automatically added &lt;span class=&quot;code&quot;&gt;A.B.G&lt;/span&gt; along
with a period separator to each path in my table. And it has done this for all
the paths in my table in a single operation.&lt;/p&gt;
&lt;h2&gt;Moving a Branch&lt;/h2&gt;
&lt;p&gt;Now using &lt;span class=&quot;code&quot;&gt;||&lt;/span&gt; I can write a single SQL statement to
move a tree branch from one location to another. First, of course, I need to
scope the SQL operation to the target branch using the ancestor operator:&lt;/p&gt;
&lt;pre&gt;
select 'A.B.G' || path as concatenated from tree where path &lt;@ 'A.C';
concatenated 
---------------
A.B.G.A.C
A.B.G.A.C.D
A.B.G.A.C.E
A.B.G.A.C.F
(4 rows)
&lt;/pre&gt;
&lt;p&gt;I get the same results as above, but now only for the tree nodes I want to
move.&lt;/p&gt;
&lt;p&gt;But my next problem is the new paths above start with &lt;span
class=&quot;code&quot;&gt;A.B.G.A.C&lt;/span&gt;…. Instead, I want them to be &lt;span
class=&quot;code&quot;&gt;A.B.G.C&lt;/span&gt;…. I need to remove that extra &lt;span
class=&quot;code&quot;&gt;A&lt;/span&gt; character from the new paths, using the &lt;span
class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt; operator:&lt;/p&gt;
&lt;pre&gt;
select 'A.B.G' || subpath(path, 1) as concatenated from tree where path &lt;@ 'A.C';
concatenated 
--------------
A.B.G.C
A.B.G.C.D
A.B.G.C.E
A.B.G.C.F
(4 rows)
&lt;/pre&gt;
&lt;p&gt;And finally, converting this into an update statement:&lt;/p&gt;
&lt;pre&gt;
update tree set path = 'A.B.G' || subpath(path, 1) where path &lt;@ 'A.C'
&lt;/pre&gt;
&lt;p&gt;…I have the single SQL statement I need!&lt;/p&gt;
&lt;p&gt;And generalizing this, we arrive at a SQL formula you could use in your own
Postgres database:&lt;/p&gt;
&lt;pre&gt;
update tree set path = DESTINATION_PATH || subpath(path, nlevel(SOURCE_PATH)-1)
where path &lt;@ SOURCE_PATH;
&lt;/pre&gt;
&lt;h2&gt;Copying a Branch&lt;/h2&gt;
&lt;p&gt;One last puzzle: How can I copy a tree branch instead of moving it? I just use
an insert SQL statement instead of update. Simple, right?&lt;/p&gt;
&lt;p&gt;But how, exactly? I need to insert multiple rows, one record for each node in
the branch I copy. Again, I could write a series of insert statements like
this:&lt;/p&gt;
&lt;pre&gt;
insert into tree (letter, path) values ('C', 'A.B.G.C');
insert into tree (letter, path) values ('D', 'A.B.G.C.D');
insert into tree (letter, path) values ('E', 'A.B.G.C.E');
insert into tree (letter, path) values ('F', 'A.B.G.C.F');
&lt;/pre&gt;
&lt;p&gt;But using LTREE functions and operators, I can achieve this using a single SQL
statement! I just have to write SQL that will insert the result of a select,
like this:&lt;/p&gt;
&lt;pre&gt;
insert into tree (letter, path) (
    select letter, 'A.B.G' || subpath(path, 1) from tree where 'A.C' @&gt; path
)
&lt;/pre&gt;
&lt;p&gt;Executing this, Postgres will first find all the nodes inside the branch I want
to copy, and recalculate their paths. Then it will insert that result set into
the tree as a copy, leaving my original branch unchanged!&lt;/p&gt;
&lt;p&gt;By writing this tree-related logic using LTREE operators in SQL, I ask Postgres
to do all of the hard work of manipulating and copying the path strings for me.
I don’t have to write application code to keep track of these strings, and no
data needs to be transmitted back and forth between my application server and
the database server.&lt;/p&gt;
&lt;h2&gt;What’s Next? LTREE Internals&lt;/h2&gt;
&lt;p&gt;In my last post about LTREE, I’ll look closely at how it works internally. It’s
easy enough to imagine how simple functions like &lt;span
class=&quot;code&quot;&gt;NLEVEL&lt;/span&gt;, || or &lt;span class=&quot;code&quot;&gt;SUBPATH&lt;/span&gt; work.
That’s not the interesting part for me. These functions are shorthand for
fairly simple string operations.&lt;/p&gt;
&lt;p&gt;The special sauce that makes LTREE such a powerful tool is that it integrates
with Postgres GiST indexes. By using an index, Postgres can execute any of the
SQL expressions I wrote above equally fast on 7000 records as it would on 7!
How? The only way to find out is by &lt;a href=&quot;http://patshaughnessy.net/2017/12/15/looking-inside-postgres-at-a-gist-index&quot;&gt;Looking Inside Postgres at a GiST
Index&lt;/a&gt;.&lt;/p&gt;
</content></entry></feed>